Done. 1. Remove bsort from Eq 
Done. 2. 'msg' in 'str_error' should be of (string list)
Done. 3. split 'case' syntax into 'case', 'sumcase' and 'unpack'
Done. 4. 'case' and 'unpack' should allow omitting return-clause and try to forget unescapable variables (like what 'let' does)
Done. 5. Distill the 'bind' pattern
Done. 6. Disallow impredicative universal types
Done. 7. Type inference
Done. 8. Idx inference
9. Allow [datatype] to have idx arguments that don't change.
Done. 10. Multi-argument idx functions.
Done. 11. Add an optional idx to [Quan], to link the remaining unification variables in types and the witnesses found by the Master Theorem solver.
Done. 12. Infer by Master Theorem then check.
Done. 13. Single variable Master Theorem case.
Done. 14. Error line number on multiple files.
Done. 15. Make linking between inferred existential variable values and types better.
Done. 16. Copy function signature annotation to case annotation
Abondoned. Unit and product types are required to define datatypes. 17. Remove unit and product types from the language, and have standard library.
Done. 18. Example: Tree flatten.
Done. 19. Example: Insertion sort.
20. Have reference and arrays.
Done. 21. RB-tree insertion.
Done. 22. RB-tree lookup.
Done. 23. Braun tree insertion.
24. A bug of position reporting when I change bigO spec of msort in msort.timl from [$m * $n * log2 $n] to [$n * log2 $n].
Done. 25. 'return _ using' works but 'return using' doesn't in msort.timl and tree.timl.
Done. 26. Change syntax order of function name and [t] declares.
Done. 27. Be able to infer for [tree_map] and [tree_foldl].
28. Have module system.
Done. 29. Bug of type inference in tree_append_rlm. The inferred type has [{n} tree tree] and [{n} list list].
Done. 30. Put [Unit] back to mtype from [base_type] because [Unit] is not a base type like [Int] but a structural building block.
31. Have a good error message when insertion_sort.timl/[insert] doesn't have the needed return-annotation on [case].
Done. 32. Be able to infer for [insertion_sort].
33. [unify]'s [(UVar, UVar)] case could be dangerous: shift_invis may not be transactional, and there is no circularity check.
Done. 34. Have a standard library.
Done. 35. Automatically generate premises in [(VarP, Never)] case of [match_ptrn], from complement cover of previous rules.
Done. 36. [case] should also copy [fun]'s [return] clause even without [using].
Abondoned. No problem. 37. [as] pattern may have a problem in [balance_left].
Done. 38. Bug: redundancy checker runs forever on [balance_left].
KIND OF UNDERSTOOD. 39. rbt.timl typecheckes when using ForgetError-less [subst] and ForgetError-full [forget]. Investigate why.
Done. 40. [find_habitant] can further simplify covers and speed up.
41. Have [type =] type aliasing.
Done. 42. Maximally insertion of index arguments.
Done. 43. Maximally insertion of index arguments in patterns.
Done. 44. nouvar-expr/passp/Imply/_ is not sound, possibly losing information.
45. [subst_invis_no_throw] should be implemented in a safe way where uvars that can see the target variable are unified with a new shifted uvars that can't see it, and [bring_forward_anchor] needs to be more sophisticated to only put new anchor when there is no shift (and the notifier in [Exists] needs to do some shift) because now not every uvar has an anchor.
Dono. 46. Braun tree extraction.
Done. 47. rename "peel_" to "collect_".
Done. 48. Register admitted things.
49. Make SMT batch response parsing smarter (don't check response length beforehand)
Done. 50. Simplify MaxI using SMT solver.
51. Have binary search with arrays.
52. Have binary heap with arrays.
53. Have in-place merge sort with arrays.
54. Have k-median search with arrays.
55. Investigate amortized complexity analysis.
56. Prove in Coq.
57. Infer [BigO] arity.
58. Have built-in indexed [uint].
59. Pretty-print to SML.

Add <> notation.
Let return clause in [Case] to mean the time including the matchee.
Amortized complexity of queue implementation by two stacks.
Infer type according to pattern.
