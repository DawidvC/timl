Done. 1. Remove bsort from Eq 
Done. 2. 'msg' in 'str_error' should be of (string list)
Done. 3. split 'case' syntax into 'case', 'sumcase' and 'unpack'
Done. 4. 'case' and 'unpack' should allow omitting return-clause and try to forget unescapable variables (like what 'let' does)
Done. 5. Distill the 'bind' pattern
Done. 6. Disallow impredicative universal types
Done. 7. Type inference
Done. 8. Idx inference
9. Allow [datatype] to have idx arguments that don't change.
Done. 10. Multi-argument idx functions.
Done. 11. Add an optional idx to [Quan], to link the remaining unification variables in types and the witnesses found by the Master Theorem solver.
Done. 12. Infer by Master Theorem then check.
Done. 13. Single variable Master Theorem case.
Done. 14. Error line number on multiple files.
Done. 15. Make linking between inferred existential variable values and types better.
Done. 16. Copy function signature annotation to case annotation
Abondoned. Unit and product types are required to define datatypes. 17. Remove unit and product types from the language, and have standard library.
Done. 18. Example: Tree flatten.
Done. 19. Example: Insertion sort.
20. Have reference and arrays.
Done. 21. RB-tree insertion.
Done. 22. RB-tree lookup.
Done. 23. Braun tree insertion.
24. A bug of position reporting when I change bigO spec of msort in msort.timl from [$m * $n * log2 $n] to [$n * log2 $n].
Done. 25. 'return _ using' works but 'return using' doesn't in msort.timl and tree.timl.
Done. 26. Change syntax order of function name and [t] declares.
Done. 27. Be able to infer for [tree_map] and [tree_foldl].
28. Have module system.
    Road map to add module system:
Done. (1) Have a barebone module system with only modules, signatures, sealing, functors and 'open'. No hierarchy (embeded modules), module alias, signature alias, 'where'/'sharing', 'include'.
    (2) Combine name-resolve and typecheck.
    (3) Combine cctx and tctx into tctx.
    (4) Combine idx and type into constructors, sort and kind into kind, Combine sctx and kctx into kctx.
    (5) Add record types.
    (6) Add singleton kinds, dependent record kinds, dependent arrow kinds.
    (7) Elaborate modules and signatures into core language.
Done. 29. Bug of type inference in tree_append_rlm. The inferred type has [{n} tree tree] and [{n} list list].
Done. 30. Put [Unit] back to mtype from [base_type] because [Unit] is not a base type like [Int] but a structural building block.
31. Have a good error message when insertion_sort.timl/[insert] doesn't have the needed return-annotation on [case].
Done. 32. Be able to infer for [insertion_sort].
33. [unify]'s [(UVar, UVar)] case could be dangerous: shift_invis may not be transactional, and there is no circularity check.
Done. 34. Have a standard library.
Done. 35. Automatically generate premises in [(VarP, Never)] case of [match_ptrn], from complement cover of previous rules.
Done. 36. [case] should also copy [fun]'s [return] clause even without [using].
Abondoned. No problem. 37. [as] pattern may have a problem in [balance_left].
Done. 38. Bug: redundancy checker runs forever on [balance_left].
Done.. 39. rbt.timl typecheckes when using ForgetError-less [subst] and ForgetError-full [forget]. Investigate why.
Done. 40. [find_habitant] can further simplify covers and speed up.
41. Have [type =] type aliasing.
Done. 42. Maximally insertion of index arguments.
Done. 43. Maximally insertion of index arguments in patterns.
Done. 44. nouvar-expr/passp/Imply/_ is not sound, possibly losing information.
45. [subst_invis_no_throw] should be implemented in a safe way where uvars that can see the target variable are unified with a new shifted uvars that can't see it, and [bring_forward_anchor] needs to be more sophisticated to only put new anchor when there is no shift (and the notifier in [Exists] needs to do some shift) because now not every uvar has an anchor.
Dono. 46. Braun tree extraction.
Done. 47. rename "peel_" to "collect_".
Done. 48. Register admitted things.
49. Make SMT batch response parsing smarter (don't check response length beforehand)
Done. 50. Simplify MaxI using SMT solver.
51. Have binary search with arrays.
52. Have binary heap with arrays.
53. Have in-place merge sort with arrays.
54. Have k-median search with arrays.
Done. 55. Investigate amortized complexity analysis.
56. Prove in Coq.
57. Infer [BigO] arity.
58. Have built-in indexed [uint].
59. Pretty-print to SML.
60. Combine cctx and tctx.
61. Add <> notation.
62. Let return clause in [Case] to mean the time including the matchee.
63. Amortized complexity of queue implementation by two stacks.
64. Infer type according to pattern.
65. Wrongly inferred [T_insert_delete_seq_0] to be (fn n => $n) without the [2.0 + 48.0 * $n] annotation.
66. Have some Nat/Time inference.
67. Unify [UnOpI], [DivI] and [ExpI].
68. Change [unify_s] to [is_sub_sort].
Done. 69. Should apply solvers and check no-uvar after every module, not every file (unless we enforce one-module-per-file policy). 
70. Move VC openings from [check_decl] to [check_decls].
71. [subst] should do lazy shifting, not eager.
Done. 72. The last two examples in bigO-evolve.timl about using [idx] instead of [absidx] doesn't work now.
73. Simplify unused 'forall' in [prop]. The unused foralls are Big-O premises.
74. [BigOEvolveSealed] in bigO-evolve.timl doesn't work yet.
75. if-then-else syntax.
76. Restore the version of [link_sig] in revision 00ba072, because a module may have uvars before sealing, and uvars can't be retrieved from a module.
77. Big-O solver should heuristically distinguish "defining" side of [TimeFun] uvars from the "using" side, by the rule-of-thumb that only [_ <= f x] is a defining constraint of [f].
78. Do a module dependent analysis of each module and only bring the needed modules into [gctx] VC context.
79. Have double-linked lists.
80. rbt6.timl: (1) local [open LogFacts]; (2) absidx sort inference in [IntKey]
