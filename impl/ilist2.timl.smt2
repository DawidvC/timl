(set-logic QF_NRA)
;; (set-option :produce-proofs true)

;; (declare-fun log2 (Real) Real)
;; (assert (forall ((x Real) (y Real))
;;                 (! (=> (and (< 0 x) (< 0 y)) (= (log2 (* x y)) (+ (log2 x) (log2 y))))
;;                    :pattern ((log2 (* x y))))))
;; (assert (forall ((x Real) (y Real))
;;                 (! (=> (and (< 0 x) (< 0 y)) (= (log2 (/ x y)) (- (log2 x) (log2 y))))
;;                    :pattern ((log2 (/ x y))))))
;; (assert (= (log2 1) 0))
;; (assert (= (log2 2) 1))
;; (assert (forall ((x Real) (y Real)) (=> (and (< 0 x) (< 0 y)) (=> (< x y) (< (log2 x) (log2 y))))))
;; (assert (forall ((x Real)) (=> (< 0 x) (= (log2 (/ 1 x)) (- 0 (log2 x))))))

;; (push)
(declare-const n2 Real)
(assert (<= 0 n2))
(declare-const n1 Real)
(assert (<= 0 n1))
(declare-const AAA0 Real)
(assert (<= 0 AAA0))
(declare-const AAA Real)
(assert (<= 0 AAA))
(declare-const n Real)
(assert (<= 0 n))
(declare-const m Real)
(assert (<= 0 m))
(assert (= (+ n1 n2) n))
(assert (= (+ AAA0 1) AAA))
(assert (= (+ AAA 1) n))
(assert (and (<= n2 n1) (<= n1 (+ n2 1))))

(assert (<= 1 n1))
(assert (<= 1 n2))
(assert (<= 2 n))

;; (assert (not (<= (+ (+ (+ 1 (+ (+ 1 (* (* m n1) n1)) (+ 1 (* (* m n2) n2)))) 1) (* (+ m 2) (+ n1 n2))) (- (* (* m n) n) (+ 1 n)))))
;; (assert (not (<= (+ (+ (+ 1 (+ (+ 1 (* 4 (* (+ m 3) (* n1 (log2 n1))))) (+ 1 (* 4 (* (+ m 3) (* n2 (log2 n2))))))) 1) (* (+ m 2) (+ n1 n2))) (- (* 4 (* (+ m 3) (* n (log2 n)))) (+ 1 n)))))
;; (assert (not (<= (+ (+ (+ 1 (+ (+ 1 (* 2.27 (* (+ m 3) (* n1 (log2 n1))))) (+ 1 (* 2.27 (* (+ m 3) (* n2 (log2 n2))))))) 1) (* (+ m 2) (+ n1 n2))) (- (* 2.27 (* (+ m 3) (* n (log2 n)))) (+ 1 n)))))

;; (assert (<= (+ 5 (+ (* (+ m 3) n) (* 4 (* (+ m 3) (+ (* n1 (log2 n1)) (* n2 (log2 n2))))))) (+ 5 (+ (* (+ m 3) n) (* 4 (* (+ m 3) (* n (log2 n1))))))))
;; (assert (not (<= (+ 5 (+ (* (+ m 3) n) (* 4 (* (+ m 3) (+ (* n1 (log2 n1)) (* n2 (log2 n2))))))) (* 4 (* (+ m 3) (* n (log2 n)))))))
(assert (not (<= (+ 5 (+ (* (+ m 3) n) (* 4 (* (+ m 3) (* n (/ (log n1) (log 2))))))) (* 4 (* (+ m 3) (* n (/ (log n) (log 2))))))))
;; (assert (<= (/ 3 2) (+ 1 (/ n2 n1))))
;; (assert (not (<= 0.58496 (/ (log (/ 3 2)) (log 2)))))
;; (assert (<= 0.58496 (log2 (/ 3 2))))
(assert (<= n 100000000000000000000))
(assert (not (<= (+ (/ 5 (* 4 (* (+ m 3) n))) (/ 1 4)) (/ (log (+ 1 (/ n2 n1))) (log 2)))))

(check-sat)
;; (get-model)
;; (eval (log2 (/ 3 2)))
;; (pop)

;; (push)
;; (assert (< (log2 3) (log2 2)))

;; (check-sat)
;; (get-model)
;; (get-proof)
;; (pop)

(exit)
