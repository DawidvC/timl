datatype {Nat} 'a ilist =
         NilI of unit -> {0} 'a ilist
         | ConsI of {n' : Nat} 'a * {n'} 'a ilist -> {n' + 1} 'a ilist

datatype {Nat} {Bool} 'a rbt =
         Leaf of unit -> {0} {true} 'a rbt
         | Black of {lc : Bool} {rc : Bool} {bh : Nat}
                                'a * {bh} {lc} 'a rbt * {bh} {rc} 'a rbt -> {bh + 1} {true} 'a rbt
         | Red of {bh : Nat}
                      'a * {bh} {true} 'a rbt * {bh} {true} 'a rbt -> {bh} {false} 'a rbt

val n = 77

val _ =
    let                                                              
        val n = 77
    in
        n
    end

val _ = 
 fn ['a] {n : Nat} (ls : {n} 'a ilist) =>
    case ls of
        NilI _ => 0
      | ConsI {_} _ => 0

val map = 
 fn ['a] ['b] {m : Nat} (f : 'a -- m -> 'b) =>
    fix (map : forall {n : Nat}, {n} 'a ilist -- (m + 2) * n -> {n} 'b ilist) {n : Nat} (ls : {n} 'a ilist) =>
    case ls return {n} 'b ilist |> (m + 2) * n of
        NilI _ => NilI ['b] ()
      | ConsI {n'} x_xs => ConsI ['b] {n'} (f (fst x_xs), map {n'} (snd x_xs))

(* omit time in return clause *)
val map2 = 
 fn ['a] ['b] {m : Nat} (f : 'a -- m -> 'b) =>
    fix (map : forall {n : Nat}, {n} 'a ilist -- (m + 2) * n -> {n} 'b ilist) {n : Nat} (ls : {n} 'a ilist) =>
    case ls return {n} 'b ilist of
        NilI _ => NilI ['b] () 
      | ConsI {n'} x_xs => ConsI ['b] {n'} (f (fst x_xs), map {n'} (snd x_xs)) |> (m + 2) * n

(* omit return clause *)
val map3 = 
 fn ['a] ['b] {m : Nat} (f : 'a -- m -> 'b) =>
    fix (map : forall {n : Nat}, {n} 'a ilist -- (m + 2) * n -> {n} 'b ilist) {n : Nat} (ls : {n} 'a ilist) =>
    case ls of
        NilI _ => NilI ['b] () : {n} 'b ilist
      | ConsI {n'} x_xs => ConsI ['b] {n'} (f (fst x_xs), map {n'} (snd x_xs)) : {n} 'b ilist |> (m + 2) * n

val map4 = 
 fn ['a] ['b] {m : Nat} (f : 'a -- m -> 'b) =>
    fix (map : forall {n : Nat}, {n} 'a ilist -- (m + 2) * n -> {n} 'b ilist) {n : Nat} (ls : {n} 'a ilist) =>
    case ls return {n} 'b ilist |> (m + 2) * n of
        NilI => NilI ['b] ()
      | ConsI {n'} (x, xs as NilI) => ConsI ['b] {n'} (f x, map {n'} xs)
      | ConsI {n'} (x, xs) => ConsI ['b] {n'} (f x, map {n'} xs)

val map5 = 
 fn ['a] ['b] {m : Nat} (f : 'a -- m -> 'b) =>
    fix (map : forall {n : Nat}, {n} 'a ilist -- (m + 2) * n -> {n} 'b ilist) {n : Nat} (ls : {n} 'a ilist) =>
    case ls return {n} 'b ilist |> (m + 2) * n of
        NilI => NilI ['b] ()
                                                                                                               
