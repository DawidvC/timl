open MicroTiMLInst
open ShiftCstr
open SubstCstr

type nkctx = string list
type ktctx = string list
type nctx = nkctx * ktctx

fun name2index x ls =
  case ls of
      [] => raise Not_found
    | y :: rest => if y = x then 0 else 1 + (name2index x rest)

fun add_type t (kctx, tctx) = (kctx, t :: tctx)
fun add_kind k (kctx, tctx) = (k :: kctx, map shift0_c_c tctx)

fun add_tname x (nkctx, ntctx) = (nkctx, x :: ntctx)
fun add_kname x (nkctx, ntctx) = (x :: nkctx, ntctx)

fun gen_value e =
  case e of
      EConst cn => as_VConst cn
    | EBinOp (EBPair, e1, e2) => as_VPair (gen_value e1) (gen_value e2)
    | EUnOp (EUInj inj, e) => as_VInj inj (gen_value e)
    | EAbs e => as_VAbs e
    | EAbsC e => as_VAbsC e
    | EPack (c, e) => as_VPack c (gen_value e)
    | EUnOp (EUFold, e) => as_VFold (gen_value e)
    | _ => raise (Impossible "gen_value")

fun check_equal a b =
  if a = b then ()
  else raise (Impossible "check_equal")

fun gen_kdeq kctx k1 k2 =
  case (k1, k2) of
      (KType, KType) => as_KdEqKType kctx
      | (KBaseSort b1, KBaseSort b2) => let val () = check_equal b1 b2 in as_KdEqBaseSort kctx b1 end
    | (KArrow (k11, k12), KArrow (k21, k22)) => as_KdEqKArrow (gen_kdeq kctx k11 k21) (gen_kdeq kctx k12 k22)
    | (KSubset (k1, p1), KSubset (k2, p2)) => as_KdEqSubset (gen_kdeq kctx k1 k2) (PrAdmit (k1 :: kctx, PIff (p1, p2)))
    | _ => raise (Impossible "gen_kdeq")

fun gen_tyeq kctx t1 t2 =
  case (t1, t2) of
      (CVar x1, CVar x2) => let val () = check_equal x1 x2 in as_TyEqVar kctx x1 end
    | (CConst cn1, CConst cn2) => let val () = check_equal cn1 cn2 in as_TyEqConst kctx cn1 end
    | (CUnOp (opr1, t1), CUnOp (opr2, t2)) => let val () = check_equal opr1 opr2 in as_TyEqUnOp opr1 (gen_tyeq kctx t1 t2) end
    | (CBinOp (opr1, t11, t12), CBinOp (opr2, t21, t22)) => let val () = check_equal opr1 opr2 in as_TyEqBinOp opr1 (gen_tyeq kctx t11 t21) (gen_tyeq kctx t12 t22) end
    | (CIte (t11, t12, t13), CIte (t21, t22, t23)) => as_TyEqIte (gen_tyeq kctx t11 t21) (gen_tyeq kctx t12 t22) (gen_tyeq kctx t13 t23)
    | (CTimeAbs a1, CTimeAbs a2) => let val () = check_equal a1 a2 in as_TyEqTimeAbs kctx a1 end
    | (CTimeApp (arity1, c11, c12), CTimeApp (arity2, c21, c22)) => let val () = check_equal arity1 arity2 val () = check_equal c11 c21 val () = check_equal c12 c22 in as_TyEqTimeApp kctx arity1 c11 c12 end
    | (CArrow (t11, i1, t12), CArrow (t21, i2, t22)) => as_TyEqArrow (gen_tyeq kctx t11 t21) (PrAdmit (kctx, TEq (i1, i2))) (gen_tyeq kctx t12 t22)
    | (CAbs a1, CAbs a2) => let val () = check_equal a1 a2 in as_TyEqAbs kctx a1 end
    | (CQuan (QuanForall, k1, t1), CQuan (QuanForall, k2, t2)) => as_TyEqQuan QuanForall (gen_kdeq kctx k1 k2) (gen_tyeq (k1 :: kctx) t1 t2)
    | (CQuan (QuanExists, k1, t1), CQuan (QuanExists, k2, t2)) => as_TyEqQuan QuanExists (gen_kdeq kctx k1 k2) (gen_tyeq (k1 :: kctx) t1 t2)
    | (CRec (k1, t1), CRec (k2, t2)) => as_TyEqRec (gen_kdeq kctx k1 k2) (gen_tyeq (k1 :: kctx) t1 t2)
    | (CTypeNat i1, CTypeNat i2) => as_TyEqNat (PrAdmit (kctx, NEq (i1, i2)))
    | (CTypeArr (t1, i1), CTypeArr (t2, i2)) => as_TyEqTypeArr (gen_tyeq kctx t1 t2) (PrAdmit (kctx, NEq (i1, i2)))
    | (CApp (CAbs t1, t2), t3) => if t3 = subst0_c_c t2 t1 then as_TyEqBeta kctx t1 t2 else (case t3 of CApp (t31, t32) => as_TyEqApp (gen_tyeq kctx (CAbs t1) t31) (gen_tyeq kctx t2 t32) | _ => raise (Impossible "gen_tyeq"))
    | (t3, CApp (CAbs t1, t2)) => if t3 = subst0_c_c t2 t1 then as_TyEqBetaRev kctx t1 t2 else (case t3 of CApp (t31, t32) => as_TyEqApp (gen_tyeq kctx t31 (CAbs t1)) (gen_tyeq kctx t32 t2) | _ => raise (Impossible "gen_tyeq"))
    | (CApp (t11, t12), CApp (t21, t22)) => as_TyEqApp (gen_tyeq kctx t11 t21) (gen_tyeq kctx t12 t22)
    | _ => raise (Impossible "gen_tyeq")

%%

%name MicroTiML

%term LCID of string
    | UCID of string
    | LPAREN
    | RPAREN
    | COLON
    | RTRI
    | LSQUARE
    | RSQUARE
    | LCURLY
    | RCURLY
    | PLUS
    | NPLUS
    | RPLUS
    | TPLUS
    | NMINUS
    | RMINUS
    | NMULT
    | RMULT
    | TMULT
    | MULT
    | DIV
    | ARROW
    | DARROW
    | VBAR
    | TILDE
    | CONJ
    | DISJ
    | IFF
    | NEQ
    | NLE
    | NGE
    | NLT
    | NGT
    | REQ
    | RGE
    | RLE
    | RLT
    | RGT
    | TT
    | FN
    | PAIR
    | FST
    | SND
    | INL
    | INR
    | CASE
    | FOLD
    | UNFOLD
    | PACK
    | UNPACK
    | REC
    | LET
    | NEW
    | READ
    | WRITE
    | TRUE
    | FALSE
    | TUNIT
    | TINT
    | ITE
    | TIMEAPP
    | TIMEABS
    | BIGO
    | MIN
    | MAX
    | CEIL
    | FLOOR
    | LOG
    | N2T
    | B2N
    | FORALL
    | EXISTS
    | TNAT
    | TARR
    | SNAT
    | SBOOL
    | SUNIT
    | STFUN
    | INTV of int
    | NATV of int
    | REALV of string
    | EOF
    | BOGUS of string

%nonterm term of ctx * nctx -> typing
       | cstr of kctx * nkctx -> kinding
       | kind of kctx * nkctx -> wfkind
       | prop of kctx * nkctx -> wfprop
       | cbinop of cstr_bin_op
       | cunop of cstr_un_op
       | sort of sort
       | pbinconn of prop_bin_conn
       | pbinpred of prop_bin_pred

%keyword TT FN PAIR FST SND INL INR CASE FOLD UNFOLD PACK UNPACK REC LET NEW READ WRITE TRUE FALSE TUNIT TINT ITE TIMEAPP TIMEABS BIGO MIN MAX CEIL FLOOR LOG N2T B2N FORALL EXISTS TNAT TARR SNAT SBOOL SUNIT STFUN

%pos pos

%eop EOF
%noshift EOF
%nodefault
%verbose

%arg (reporter) : reporter

%%

term : LCID (fn (ctx, (_, ntctx)) => as_TyVar ctx (name2index LCID ntctx))
     | TT (fn (ctx, _) => as_TyConst ctx ECTT)
     | INTV (fn (ctx, _) => as_TyConst ctx (ECInt INTV))
     | NATV (fn (ctx, _) => as_TyConst ctx (ECNat (Nat.from_int NATV)))
     | LPAREN PAIR term term RPAREN (fn arg => as_TyPair (term1 arg) (term2 arg))
     | LPAREN FST term RPAREN (fn arg => as_TyProj ProjFst (term arg))
     | LPAREN SND term RPAREN (fn arg => as_TyProj ProjSnd (term arg))
     | LPAREN INL term cstr RPAREN (fn (arg as ((kctx, _), (nkctx, _))) => as_TyInj InjInl (term arg) (cstr (kctx, nkctx)))
     | LPAREN INR term cstr RPAREN (fn (arg as ((kctx, _), (nkctx, _))) => as_TyInj InjInr (term arg) (cstr (kctx, nkctx)))
     | LPAREN CASE LPAREN LCID term RPAREN term term RPAREN
                (fn (arg as (ctx, nctx)) =>
                    let
                        val ty = term1 arg
                        val jty = extract_judge_typing ty
                        val (t_inl, t_inr) = extract_c_sum (#3 jty)
                        val ctx_inl = add_type t_inl ctx
                        val ctx_inr = add_type t_inr ctx
                        val nctx' = add_tname LCID nctx
                    in
                        as_TyCase ty (term2 (ctx_inl, nctx')) (term3 (ctx_inr, nctx'))
                    end)
     | LPAREN FOLD term cstr RPAREN (fn (arg as ((kctx, _), (nkctx, _))) => as_TyFold (cstr (kctx, nkctx)) (term arg))
     | LPAREN UNFOLD term RPAREN (fn arg => as_TyUnfold (term arg))
     | LPAREN PACK cstr term cstr RPAREN (fn (arg as ((kctx, _), (nkctx, _))) => as_TyPack (cstr2 (kctx, nkctx)) (cstr1 (kctx, nkctx)) (term arg))
     | LPAREN UNPACK LPAREN UCID LCID term RPAREN term RPAREN
                (fn (arg as (ctx, nctx)) =>
                    let
                        val ty = term1 arg
                        val jty = extract_judge_typing ty
                        val (q, k, t) = extract_c_quan (#3 jty)
                        val ctx' = add_type t (add_kind k ctx)
                        val nctx' = add_tname LCID (add_kname UCID nctx)
                    in
                        if q = QuanExists then as_TyUnpack ty (term2 (ctx', nctx')) else raise (Impossible "unpack a non-existential value")
                    end)
     | LPAREN REC LPAREN LCID COLON cstr RPAREN term RPAREN
                (fn (arg as (ctx as (kctx, _), nctx as (nkctx, _))) =>
                    let
                        val kd = cstr (kctx, nkctx)
                        val jkd = extract_judge_kinding kd
                        val ctx' = add_type (#2 jkd) ctx
                        val nctx' = add_tname LCID nctx
                    in
                        as_TyRec kd (term (ctx', nctx'))
                    end)
     | LPAREN LET LPAREN LCID term RPAREN term RPAREN
                (fn (arg as (ctx, nctx)) =>
                    let
                        val ty1 = term1 arg
                        val jty1 = extract_judge_typing ty1
                        val ctx' = add_type (#3 jty1) ctx
                        val nctx' = add_tname LCID nctx
                    in
                        as_TyLet ty1 (term2 (ctx', nctx'))
                    end)
     | LPAREN NEW term term RPAREN (fn arg => as_TyNew (term1 arg) (term2 arg))
     | LPAREN READ term term RPAREN
                (fn (arg as ((kctx, _), _)) =>
                    let
                        val ty1 = term1 arg
                        val ty2 = term2 arg
                        val jty1 = extract_judge_typing ty1
                        val jty2 = extract_judge_typing ty2
                        val (t, j1) = extract_c_type_arr (#3 jty1)
                        val j2 = extract_c_type_nat (#3 jty2)
                    in
                        as_TyRead ty1 ty2 (PrAdmit (kctx, NLt (j2, j1)))
                    end)
     | LPAREN WRITE term term term RPAREN
                (fn (arg as ((kctx, _), _)) =>
                    let
                        val ty1 = term1 arg
                        val ty2 = term2 arg
                        val ty3 = term3 arg
                        val jty1 = extract_judge_typing ty1
                        val jty2 = extract_judge_typing ty2
                        val jty3 = extract_judge_typing ty3
                        val (t, j1) = extract_c_type_arr (#3 jty1)
                        val j2 = extract_c_type_nat (#3 jty2)
                    in
                        as_TyWrite ty1 ty2 (PrAdmit (kctx, NLt (j2, j1))) ty3
                    end)
     | LPAREN FN LPAREN LCID COLON cstr RPAREN term RPAREN
                (fn (arg as (ctx as (kctx, _), nctx as (nkctx, _))) =>
                    let
                        val kd = cstr (kctx, nkctx)
                        val jkd = extract_judge_kinding kd
                        val ctx' = add_type (#2 jkd) ctx
                        val nctx' = add_tname LCID nctx
                    in
                        as_TyAbs kd (term (ctx', nctx'))
                    end)
     | LPAREN FN LCURLY UCID COLON kind RCURLY term RPAREN
                (fn (arg as (ctx as (kctx, _), nctx as (nkctx, _))) =>
                    let
                        val wk = kind (kctx, nkctx)
                        val jwk = extract_judge_wfkind wk
                        val ctx' = add_kind (#2 jwk) ctx
                        val nctx' = add_kname UCID nctx
                        val ty = term (ctx', nctx')
                        val jty = extract_judge_typing ty
                    in
                        as_TyAbsC wk (gen_value (#2 jty)) ty
                    end)
     | LPAREN term term RPAREN (fn arg => as_TyApp (term1 arg) (term2 arg))
     | LPAREN term LSQUARE cstr RSQUARE RPAREN
                (fn (arg as ((kctx, _), (nkctx, _))) =>
                    let
                        val ty = term arg
                        val kd = cstr (kctx, nkctx)
                    in
                        as_TyAppC ty kd
                    end)
     | LPAREN term COLON cstr RPAREN
                (fn (arg as ((kctx, _), (nkctx, _))) =>
                    let
                        val ty = term arg
                        val kd = cstr (kctx, nkctx)
                        val jty = extract_judge_typing ty
                        val jkd = extract_judge_kinding kd
                    in
                        as_TySubTy ty (gen_tyeq kctx (#3 jty) (#2 jkd))
                    end)
     | LPAREN term RTRI cstr RPAREN
                (fn (arg as ((kctx, _), (nkctx, _))) =>
                    let
                        val ty = term arg
                        val kd = cstr (kctx, nkctx)
                        val jty = extract_judge_typing ty
                        val jkd = extract_judge_kinding kd
                    in
                        as_TySubTi ty (PrAdmit (kctx, TLe (#4 jty, #2 jkd)))
                    end)
     | LPAREN PLUS term term RPAREN (fn arg => as_TyPrimBinOp PEBIntAdd (term1 arg) (term2 arg))

cstr : UCID (fn (kctx, nkctx) => as_KdVar kctx (name2index UCID nkctx))
     | TT (fn (kctx, _) => as_KdConst kctx CCIdxTT)
     | TRUE (fn (kctx, _) => as_KdConst kctx CCIdxTrue)
     | FALSE (fn (kctx, _) => as_KdConst kctx CCIdxFalse)
     | INTV (fn (kctx, _) => as_KdConst kctx (CCIdxNat (Nat.from_int INTV)))
     | REALV (fn (kctx, _) => as_KdConst kctx (CCTime (Time.from_string REALV)))
     | TUNIT (fn (kctx, _) => as_KdConst kctx CCTypeUnit)
     | TINT (fn (kctx, _) => as_KdConst kctx CCTypeInt)
     | LPAREN ITE cstr cstr cstr RPAREN (fn arg => as_KdIte (cstr1 arg) (cstr2 arg) (cstr3 arg))
     | LPAREN TIMEABS LPAREN UCID RPAREN cstr RPAREN (fn (kctx, nkctx) => as_KdTimeAbs (cstr (KNat :: kctx, UCID :: nkctx)))
     | LPAREN TIMEAPP cstr cstr RPAREN (fn arg => as_KdTimeApp (cstr1 arg) (cstr2 arg))
     | LPAREN cunop cstr RPAREN (fn arg => as_KdUnOp cunop (cstr arg))
     | LPAREN cbinop cstr cstr RPAREN (fn arg => as_KdBinOp cbinop (cstr1 arg) (cstr2 arg))
     | LPAREN ARROW cstr cstr cstr RPAREN (fn arg => as_KdArrow (cstr1 arg) (cstr3 arg) (cstr2 arg))
     | LPAREN FN LPAREN UCID COLON kind RPAREN cstr RPAREN
                (fn (arg as (kctx, nkctx)) =>
                    let
                        val wk = kind arg
                        val jwk = extract_judge_wfkind wk
                        val kctx' = #2 jwk :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_KdAbs wk (cstr (kctx', nkctx'))
                    end)
     | LPAREN FORALL LPAREN UCID COLON kind RPAREN cstr RPAREN
                (fn (arg as (kctx, nkctx)) =>
                    let
                        val wk = kind arg
                        val jwk = extract_judge_wfkind wk
                        val kctx' = #2 jwk :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_KdQuan QuanForall wk (cstr (kctx', nkctx'))
                    end)
     | LPAREN EXISTS LPAREN UCID COLON kind RPAREN cstr RPAREN
                (fn (arg as (kctx, nkctx)) =>
                    let
                        val wk = kind arg
                        val jwk = extract_judge_wfkind wk
                        val kctx' = #2 jwk :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_KdQuan QuanExists wk (cstr (kctx', nkctx'))
                    end)
     | LPAREN REC LPAREN UCID COLON kind RPAREN cstr RPAREN
                (fn (arg as (kctx, nkctx)) =>
                    let
                        val wk = kind arg
                        val jwk = extract_judge_wfkind wk
                        val kctx' = #2 jwk :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_KdRec wk (cstr (kctx', nkctx'))
                    end)
     | LPAREN TNAT cstr RPAREN (fn arg => as_KdTypeNat (cstr arg))
     | LPAREN TARR cstr cstr RPAREN (fn arg => as_KdTypeArr (cstr1 arg) (cstr2 arg))
     | LPAREN cstr cstr RPAREN (fn arg => as_KdApp (cstr1 arg) (cstr2 arg))

cbinop : NPLUS (CBNatAdd)
       | NMINUS (CBNatMinus)
       | NMULT (CBNatMult)
       | RPLUS (CBTimeAdd)
       | RMINUS (CBTimeMinus)
       | RMULT (CBTimeMult)
       | TPLUS (CBTypeSum)
       | TMULT (CBTypeProd)
       | MIN (CBTimeMin)
       | MAX (CBTimeMax)

cunop : CEIL (CUCeil)
      | FLOOR (CUFloor)
      | LOG LSQUARE INTV RSQUARE (CULog INTV)
      | DIV LSQUARE INTV RSQUARE (CUDiv INTV)
      | N2T (CUNat2Time)
      | B2N (CUBool2Nat)

kind : MULT (fn (kctx, _) => as_WfKdType kctx)
     | LPAREN DARROW kind kind RPAREN (fn arg => as_WfKdArrow (kind1 arg) (kind2 arg))
     | sort (fn (kctx, _) => as_WfKdBaseSort kctx sort)
     | LCURLY UCID COLON kind VBAR prop RCURLY
                (fn (arg as (kctx, nkctx)) =>
                    let
                        val wk = kind arg
                        val jwk = extract_judge_wfkind wk
                        val kctx' = #2 jwk :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_WfKdSubset wk (prop (kctx', nkctx'))
                    end)

sort : SNAT (BSNat)
     | SBOOL (BSBool)
     | SUNIT (BSUnit)
     | STFUN LSQUARE INTV RSQUARE (BSTimeFun INTV)

prop : TRUE (fn (kctx, _) => as_WfPropTrue kctx)
     | FALSE (fn (kctx, _) => as_WfPropFalse kctx)
     | LPAREN TILDE prop RPAREN (fn arg => as_WfPropNot (prop arg))
     | LPAREN FORALL LPAREN UCID COLON sort RPAREN prop RPAREN
                (fn (kctx, nkctx) =>
                    let
                        val kctx' = KBaseSort sort :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_WfPropQuan QuanForall sort (prop (kctx', nkctx'))
                    end)
     | LPAREN EXISTS LPAREN UCID COLON sort RPAREN prop RPAREN
                (fn (kctx, nkctx) =>
                    let
                        val kctx' = KBaseSort sort :: kctx
                        val nkctx' = UCID :: nkctx
                    in
                        as_WfPropQuan QuanExists sort (prop (kctx', nkctx'))
                    end)
     | LPAREN pbinconn prop prop RPAREN (fn arg => as_WfPropBinConn pbinconn (prop1 arg) (prop2 arg))
     | LPAREN pbinpred cstr cstr RPAREN (fn arg => as_WfPropBinPred pbinpred (cstr1 arg) (cstr2 arg))

pbinconn : CONJ (PBCAnd)
         | DISJ (PBCOr)
         | ARROW (PBCImply)
         | IFF (PBCIff)

pbinpred : BIGO LSQUARE INTV RSQUARE (PBBigO INTV)
         | NEQ (PBNatEq)
         | NGE (PBNatGe)
         | NLE (PBNatLe)
         | NGT (PBNatGt)
         | NLT (PBNatLt)
         | REQ (PBTimeEq)
         | RGE (PBTimeGe)
         | RLE (PBTimeLe)
         | RGT (PBTimeGt)
         | RLT (PBTimeLt)
