(type (List (fn (A : *) (rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) ))

(let (nil (fn {A : *} (fold ((inl (pack (tt : {U : unit | (=n 0 0)}) tt (exists (U : { U : unit | (=n 0 0)}) Unit)) (exists (N : nat) (exists (U : {U : unit | (=n 0 (+n N 1))}) (*t A ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) N))))) : ((fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) N)))))) 0)) ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) 0))))

(let (cons (fn {A : *} (fn {L : nat} (fn (h : A) (fn (t : ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) L)) (fold ((inr (pack L (pack (tt : {U : unit | (=n (+n L 1) (+n L 1))}) (pair h t) (exists (U : {U : unit | (=n (+n L 1) (+n L 1))}) (*t A ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) L)))) (exists (N : nat) (exists (U : {U : unit | (=n (+n L 1) (+n N 1))}) (*t A ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) N))))) (exists (U : {U : unit | (=n (+n L 1) 0)}) Unit)) : ((fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) N)))))) (+n L 1))) ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) (+n L 1))))))))

(let (map (rec (map : (forall (A : *) (forall (B : *) (forall (M : nat) (forall (N : nat) (-> (-> A B (n2t M)) (-> ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) N) ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t B (T N))))))) N) (*r (n2t (+n M 3)) (n2t N))) 0.0)))))) (fn {A : *} (fn {B : *} (fn {M : nat} (fn {N : nat} (fn (f : (-> A B (n2t M))) (fn (ls : ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) N)) ((case (x ((unfold ls) : (+t (exists (U : {U : unit | (=n N 0)}) Unit) (exists (K : nat) (exists (U : {U : unit | (=n N (+n K 1))}) (*t A ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t A (T N))))))) K))))))) ((nil [B]) : ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t B (T N))))))) N)) (unpack (L y x) (unpack (U p y) (let (x (fst p)) (let (xs (snd p)) ((((((cons [B]) [L]) (f x)) ((((((map [A]) [B]) [M]) [L]) f) xs)) : ((rec (T : (=> nat *)) (fn (L : nat) (+t (exists (U : {U : unit | (=n L 0)}) Unit) (exists (N : nat) (exists (U : {U : unit | (=n L (+n N 1))}) (*t B (T N))))))) N)) |> (*r (n2t (+n M 3)) (n2t N)))))))) |> (*r (n2t (+n M 3)) (n2t N)))))))))))

  tt))))