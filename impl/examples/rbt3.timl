(* Red-black tree with invariant for well-red-ness, black-height-blance and sorted-ness. Key type is indexed unsigned fixed-width integers *)

open Uint
       
datatype {Bool} color =
         Black of {true} color
         | Red of {false} color

datatype {Nat(*max*)} {Nat(*min*)} {Nat(*black height*)} {Bool} 'a rbt =
         Leaf of {0} {0} {1} {true} 'a rbt
       | Node {lcolor color rcolor : Bool} {bh lmin lmax k rmin rmax : Nat} {color = false -> lcolor = true /\ rcolor = true } {lmin <= lmax /\ (lmax < k \/ bh = 1 /\ lcolor = true) /\ (k < rmin \/ bh = 1 /\ rcolor = true) /\ rmin <= rmax} {bh >= 1} of
         {color} color * {lmax} {lmin} {bh} {lcolor} 'a rbt * ({k} uint * 'a) * {rmax} {rmin} {bh} {rcolor} 'a rbt --> {ite (bh == 1 && rcolor) k rmax} {ite (bh == 1 && lcolor) k lmin} {bh + b2n color} {color} 'a rbt

datatype {Nat} {Nat} {Nat} 'a violation =
         ViolateLeft {rcolor : Bool} {bh lmin lmax k rmin rmax : Nat} {lmin <= lmax /\ lmax < k /\ (k < rmin \/ bh = 1 /\ rcolor = true) /\ rmin <= rmax} of {lmax} {lmin} {bh} {false} 'a rbt * ({k} uint * 'a) * {rmax} {rmin} {bh} {rcolor} 'a rbt --> {ite (bh == 1 && rcolor) k rmax} {lmin} {bh} 'a violation
       | ViolateRight {lcolor : Bool} {bh lmin lmax k rmin rmax : Nat} {lmin <= lmax /\ (lmax < k \/ bh = 1 /\ lcolor = true) /\ k < rmin /\ rmin <= rmax} of {lmax} {lmin} {bh} {lcolor} 'a rbt * ({k} uint * 'a) * {rmax} {rmin} {bh} {false} 'a rbt --> {rmax} {ite (bh == 1 && lcolor) k lmin} {bh} 'a violation
                                                                             
fun balance_left ['a] {rcolor : Bool} {bh lmin lmax k rmin rmax : Nat} {lmin <= lmax /\ lmax < k /\ (k < rmin \/ bh = 1 /\ rcolor = true) /\ rmin <= rmax} (left : {lmax} {lmin} {bh} 'a violation) (center as z : {k} uint * 'a) (right as d : {rmax} {rmin} {bh} {rcolor} 'a rbt) return {ite (bh == 1 && rcolor) k rmax} {lmin} {bh + 1} {false} 'a rbt =
    case left of
        ViolateLeft (Node (Red, a, x, b), y, c) =>
        Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
      | ViolateRight (a, x, Node (Red, b, y, c)) =>
        Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
      | _ => never

fun balance_right ['a] {lcolor : Bool} {bh lmin lmax k rmin rmax : Nat} {lmin <= lmax /\ (lmax < k \/ bh = 1 /\ lcolor = true) /\ k < rmin /\ rmin <= rmax} (left as a : {lmax} {lmin} {bh} {lcolor} 'a rbt) (center as x : {k} uint * 'a) (right : {rmax} {rmin} {bh} 'a violation) return {rmax} {ite (bh == 1 && lcolor) k lmin} {bh + 1} {false} 'a rbt =
    case right of
        ViolateLeft (Node (Red, b, y, c), z, d) =>
        Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
      | ViolateRight (b, y, Node (Red, c, z, d)) =>
        Node (Red, Node (Black, a, x, b), y, Node (Black, c, z, d))
      | _ => never

(* arbt: 'almost' red black tree, except that wellredness may be violated between root and one of its children *)
datatype {Nat} {Nat} {Nat} {Bool} {Bool (*is already good?*)} 'a arbt =
         Good {color : Bool} {bh kmin kmax : Nat} of {color} color * {kmax} {kmin} {bh} {color} 'a rbt --> {kmax} {kmin} {bh} {color} {true} 'a arbt
       | Bad {bh kmin kmax : Nat} of {kmax} {kmin} {bh} 'a violation --> {kmax} {kmin} {bh} {false} {false} 'a arbt

datatype {Nat} {Nat} {Nat} {Bool} 'a ins_result =
         InsResult {input_color output_color is_good : Bool} {bh kmin kmax : Nat} {input_color = true -> is_good = true} {~ (output_color = true /\ bh = 1)}(*result can't be a leaf*) of {kmax} {kmin} {bh} {output_color} {is_good} 'a arbt --> {kmax} {kmin} {bh} {input_color} 'a ins_result

absidx g : BigO 1 (fn n => $n) (* = fn n => 6.0 * $n *) with                                   
fun ins ['a] {input_color : Bool} {bh kmin kmax k : Nat} (tr : {kmax} {kmin} {bh} {input_color} 'a rbt) (new as (k : {k} uint, _)) return {ite (bh == 1 && input_color) k (k max kmax)} {ite (bh == 1 && input_color) k (k min kmin)} {bh} {input_color} 'a ins_result using (* 6.0 * $ *)g (2 * bh + b2n (not input_color)) =
    case tr of
        Leaf =>
        let
          val tr = Node (Red, Leaf, new, Leaf)
          val tr = Good (Red, tr)
          val tr = InsResult tr
        in
          tr
        end
      | Node (Red, left, center as (k', v), right) =>
        (case cmp (k, k') of
             Equal => InsResult (Good (Red, Node (Red, left, new, right)))
           | Less =>
             let
               val (InsResult left) = ins left new
             in
               case left of
                   Good (color, left) =>
                   (case color of
                        Red =>
                        InsResult (Bad (ViolateLeft (left, center, right)))
                      | Black =>
                        (* never *)
                        InsResult (Good (Red, Node (Red, left, center(* new *)(* (Zero, v) *), right)))
                        (* InsResult (Good (Red, Node (Red, left, new, right))) *)
                   )
                 | _ => never
             end
           | Greater =>
             let
               val (InsResult right) = ins right new
             in
               case right of
                   Good (color, right) =>
                   (case color of
                        Red =>
                        InsResult (Bad (ViolateRight (left, center, right)))
                      | Black =>
                        InsResult (Good (Red, Node (Red, left, center, right)))
                   )
                 | _ => never
             end
        )
      | Node (Black, left, center as (k', _), right) =>
        (case cmp (k, k') of
             Equal =>
             InsResult (Good (Black, Node (Black, left, new, right)))
           | Less => 
             let
               val (InsResult left) = ins left new
             in
               case left of
                   Good (_, left) =>
                   InsResult (Good (Black, Node (Black, left, center, right)))
                 | Bad left =>
                   InsResult (Good (Red, balance_left left center right))
             end
           | Greater => 
             let
               val (InsResult right) = ins right new
             in
               case right of
                   Good (_, right) =>
                   InsResult (Good (Black, Node (Black, left, center, right)))
                 | Bad right =>
                   InsResult (Good (Red, balance_right left center right))
             end
        )
end

fun blacken_root ['a] {bh kmin kmax : Nat} (tr : {kmax} {kmin} {bh} {false} 'a rbt) return {kmax} {kmin} {bh + 1} {true} 'a rbt =
    case tr of
        Node (Red, l, c, r) => Node (Black, l, c, r)
      | _ => never

(* final packaging: root must be black *)
datatype {Nat} 'a rb_tree =
         RBTree {bh kmin kmax : Nat} of {kmax} {kmin} {bh} {true} 'a rbt --> {bh} 'a rb_tree


datatype {Nat} 'a rbt_may_grow_one =
         RbtMayGrowOne {bh : Nat} {bh' : Nat | bh' = bh \/ bh' = bh + 1} of {bh'} 'a rb_tree --> {bh} 'a rbt_may_grow_one

absidx Tinsert : BigO 1 (fn n => $n) with
fun insert ['a] {bh k : Nat} (tr : {bh} 'a rb_tree) (new : {k} uint * 'a) return {bh} 'a rbt_may_grow_one using Tinsert bh =
    case tr of
        RBTree tr =>
        case ins tr new of
            InsResult (Good (color, tr)) =>
            (case color of
                 Black => RbtMayGrowOne (RBTree tr)
               | Red => RbtMayGrowOne (RBTree (blacken_root tr))
            )
          | _ => never
end

absidx g : BigO 1 (fn n => $n) with
fun lookup' ['a] {color : Bool} {bh kmin kmax k : Nat} (tr : {kmax} {kmin} {bh} {color} 'a rbt) (k : {k} uint) return 'a option using g (2 * bh + b2n (not color)) =
    case tr of
        Leaf => NONE
      | Node (_, left, (k', v), right) =>
        case cmp (k, k') of
            Equal => SOME v
          | Less => lookup' left k
          | Greater => lookup' right k
end

absidx Tlookup : BigO 1 (fn n => $n) with
fun lookup ['a] {bh k : Nat} (tr : {bh} 'a rb_tree) (k : {k} uint) return 'a option using Tlookup bh =
    case tr of
        RBTree tr => lookup' tr k
end
