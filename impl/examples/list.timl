datatype {Nat} 'a list =
         NilI of unit -> {0} 'a list
         | ConsI of {n' : Nat} 'a * {n'} 'a list -> {n' + 1} 'a list

val ['a] ['b] map = 
 fn {m : Time} (f : 'a -- m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} 'a list) return {n} 'b list |> (m + 2.0) * $n =
            case ls return {n} 'b list of
                NilI => NilI
              | ConsI {n'} (x, xs) => ConsI {_} (f x, map {_} xs) |> (m + 2.0) * $n
    in
        map
    end

val ['a] ['b] foldl =
 fn {m : Time} (f : 'a * 'b -- m --> 'b) =>
    let
        fun loop {n : Nat} (y : 'b, xs : {n} 'a list) return 'b |> (m + 2.0) * $n =
            case xs of
                NilI => y
              | ConsI {n'} (x, xs) => loop {_} (f (x, y), xs) |> (m + 2.0) * $n
    in
        loop
    end

datatype {Nat} 'a even_split =
         Even of {n1 : Nat} {n2 : Nat | n2 <= n1 /\ n1 <= n2 + 1} ({n1} 'a list * {n2} 'a list) -> {n1 + n2} 'a even_split

fun ['a] split {n : Nat} (xs : {n} 'a list) return {n} 'a even_split |> $n =
    case xs return {n} 'a even_split |> $n of
        NilI => Even {0} {0} (NilI, NilI)
      | ConsI {_} (x, NilI) => Even {_} {_} (xs, NilI)
      | ConsI {_} (x1, (ConsI {n'} (x2, xs))) =>
        case split {n'} xs return {n} 'a even_split of
            Even {n1 n2} (xs1, xs2) => Even {_} {_} (ConsI {_} (x1, xs1), ConsI {_} (x2, xs2))

datatype bool = true | false

val ['a] merge =
 fn {m : Time} (le : 'a * 'a -- m --> bool) =>
    let
        fun merge {n1 : Nat} {n2 : Nat} ((xs, ys) : {n1} 'a list * {n2} 'a list) return {n1 + n2} 'a list |> (m + 2.0) * $(n1 + n2) =
            case (xs, ys) return {n1 + n2} 'a list |> (m + 2.0) * $(n1 + n2) of
                (NilI, _) => ys
              | (_, NilI) => xs
              | (ConsI {n1'} (x, xs'), ConsI {n2'} (y, ys')) =>
                case le (x, y) of
                    true => ConsI {_} (x, merge {_} {_} (xs', ys))
                  | false => ConsI {_} (y, merge {_} {_} (xs, ys'))
    in
        merge
    end

val ['a] msort =
 fn {m : Time} (le : 'a * 'a -- m --> bool) =>
    let
        fun sort {n : Nat} (xs : {n} 'a list) return {n} 'a list |> (m + 3.0) * 4.0 * $n * log2 $n =
            case xs return {n} 'a list of
                NilI => xs
              | (ConsI {_} (_, NilI)) => xs
              | (ConsI {_} (_, ConsI {_} (_, _))) =>
                case split {n} xs return {n} 'a list |> (m + 3.0) * 4.0 * $n * log2 $n - $(1 + n) of
                    Even {n1} {n2} (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
        sort
    end

(* package to big-O spec *)
val ['a] merge_sort =
    pack [exists {c : {c : Time | c > 0.0}}, forall {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- (m + 3.0) * c * $n * log2 $n --> {n} 'a list] {4.0} msort

         (*

exists {c : Time} {ub : Time}, forall {n : Nat}, {n} 'a list -- max ub (c * $n * log2 $n) --> {n} 'a list

exists {c : BigOConsts}, forall {n : Nat}, {n} 'a list -- O c ($n * log2 $n) --> {n} 'a list

exists {g : O (n => $n * log2 $n)}, forall {n : Nat}, {n} 'a list -- g n --> {n} 'a list

==========================
O (ub1,c1) (n * log n) + O (ub2,c2) n <= O ((ub1+ub2)/c2+1.73,c1+1.0) (n * log n)

==========================
exists c, O c1 (n * log n) + O c2 n <= O c (n * log n)

idx c1

idx c2

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- O c1 m * O c2 ($n * log2 $n) --> {n} 'a list

<->

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- O m * O ($n * log2 $n) --> {n} 'a list

==========================
exists c, O c1 n + O c2 n + O c3 1 <= O c n

         *)
