datatype {Nat} 'a list =
         NilI of unit -> {0} 'a list
         | ConsI of {n' : Nat} 'a * {n'} 'a list -> {n' + 1} 'a list

val ['a] ['b] map = 
 fn {m : Time} (f : 'a -- m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} 'a list) return {n} 'b list |> (m + 2.0) * $n =
            case ls return {n} 'b list of
                NilI => NilI
              | ConsI {n'} (x, xs) => ConsI {_} (f x, map {_} xs) |> (m + 2.0) * $n
    in
        map
    end

val ['a] ['b] foldl =
 fn {m : Time} (f : 'a * 'b -- m --> 'b) =>
    let
        fun loop {n : Nat} (y : 'b, xs : {n} 'a list) return 'b |> (m + 2.0) * $n =
            case xs of
                NilI => y
              | ConsI {n'} (x, xs) => loop {_} (f (x, y), xs) |> (m + 2.0) * $n
    in
        loop
    end

(* datatype {Nat} 'a even_split = *)
(*          Even of {n : Nat} ({ceil (0.5 * $n)} 'a list * {floor (0.5 * $n)} 'a list) -> {n} 'a even_split *)

fun ['a] split {n : Nat} (xs : {n} 'a list) return {ceil (0.5 * $n)} 'a list * {floor (0.5 * $n)} 'a list |> $n =
    case xs return {ceil (0.5 * $n)} 'a list * {floor (0.5 * $n)} 'a list |> $n of
        NilI => (NilI, NilI)
      | ConsI {_} (x, NilI) => (xs, NilI)
      | ConsI {_} (x1, (ConsI {n'} (x2, xs))) =>
        case split {n'} xs return {ceil (0.5 * $n)} 'a list * {floor (0.5 * $n)} 'a list of
            (xs1, xs2) => (ConsI {_} (x1, xs1), ConsI {_} (x2, xs2))
                              
datatype bool = true | false

val ['a] merge =
 fn {m : Time} (le : 'a * 'a -- m --> bool) =>
    let
        fun merge {n1 : Nat} {n2 : Nat} ((xs, ys) : {n1} 'a list * {n2} 'a list) return {n1 + n2} 'a list |> (m + 2.0) * $(n1 + n2) =
            case (xs, ys) return {n1 + n2} 'a list |> (m + 2.0) * $(n1 + n2) of
                (NilI, _) => ys
              | (_, NilI) => xs
              | (ConsI {n1'} (x, xs'), ConsI {n2'} (y, ys')) =>
                case le (x, y) of
                    true => ConsI {_} (x, merge {_} {_} (xs', ys))
                  | false => ConsI {_} (y, merge {_} {_} (xs, ys'))
    in
        merge
    end
        
abstype idx f : Fun1 = _ with
abstype idx g : {g : Fun1 | g O f} = _ with
(* abstype idx g : {g : Fun1 | g O _} = _ with *)
val ['a] msort =
 fn {m : Time} (le : 'a * 'a -- m --> bool) =>
    let
        fun sort {n : Nat} (xs : {n} 'a list) return {n} 'a list |> m * g n =
          case xs return {n} 'a list of
              NilI => xs
            | (ConsI {_} (_, NilI)) => xs
            | (ConsI {_} (_, ConsI {_} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
        sort
    end
end
end

(* Proof obligations:

exists g : Fun1, O g (fn n => n * log2 n) ->
(* or exists (f : Fun1) (g : Fun1), O g f -> *)
  forall m n,
    1 + 1 + m * g (ceil (0.5 * $n) * log2 (ceil (0.5 * $n))) + 1 + m * g (floor (0.5 * $n) * log2 (floor (0.5 * $n))) + 1 + m + 2 + n + 1 + n <= m * g (n * log2 n)

*)
