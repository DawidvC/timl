structure MSort = struct
open Basic
open List

absidx T_split: BigO 1 _ (* (fn n => $n) *) = _ with
fun split ['a] {n: Nat} (xs: list 'a {n}) return list 'a {ceil ($n/2)} * list 'a {floor ($n/2)} using T_split n =
    case xs of
        [] => ([], [])
      | [x] => (xs, [])
      | x1 :: x2 :: xs =>
        let val (xs1, xs2) = split xs in
        (x1 :: xs1, x2 :: xs2) end
end

absidx T_merge: BigO 2 (fn m n => $m * $n) = _ with
fun merge ['a] {m n1 n2: Nat} (le: 'a*'a --$m--> bool) (xs: list 'a {n1}, ys: list 'a {n2}) return list 'a {n1 + n2} using T_merge m (n1 + n2) =
    case (xs, ys) of
        ([], _) => ys
      | (_, []) => xs
      | (x :: xs', y :: ys') =>
        if le (x, y) then x :: merge le (xs', ys)
        else y :: merge le (xs, ys')
end

absidx {T : Fun 2 | T O (fn m n => $m * $n * log2 $n)} with
fun msort ['a] {m : Nat} {n : Nat} (le : 'a * 'a -- $m --> bool) (xs : list 'a {n}) return list 'a {n} using T m n =
    case xs of
        Nil => xs
      | (Cons (_, Nil)) => xs
      | (Cons (_, Cons (_, _))) =>
        case split xs of
            (xs1, xs2) => merge le (msort le xs1, msort le xs2)
end

absidx g : BigO 1 (fn n => $n) = fn n => 2.0 * $n with
fun revAppend ['a] {n1 : Nat} (xs : list 'a {n1}) {n2 : Nat} (ys : list 'a {n2}) return list 'a {n1 + n2} using g n1 =
    case xs of
        Nil => ys
      | Cons (x, xs) => revAppend xs {_} (Cons (x, ys))
end

absidx T_revAppend : BigO 1 (fn n => $n) (* = fn n => 2.0 * $n *) with
fun revAppend ['a] {n1 n2 : Nat} (xs : list 'a {n1}) (ys : list 'a {n2}) return list 'a {n1 + n2} using T_revAppend n1 =
    case xs of
        [] => ys
      | x :: xs => revAppend xs (x :: ys)
end

absidx g : BigO 1 (fn n => $n) with
fun rev ['a] {n : Nat} (xs : list 'a {n}) return list _ {n} using g n = revAppend xs Nil
end

absidx T: BigO 2 (fn m n => $m*$n*log2 $n) = _
                                               
fun msort ['a] {m n: Nat} (le: 'a*'a --$m--> bool) (xs: list 'a {n}) return list 'a {n} using T m n =
    case xs of
        [] => xs
      | [_] => xs
      | _ :: _ :: _ =>
        let val (xs1, xs2) = split xs in
          merge le (msort le xs1, msort le xs2) end
          
end
