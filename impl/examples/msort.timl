datatype {Nat} 'a list =
         Nil of unit --> {0} 'a list
         | Cons {n' : Nat} of 'a * {n'} 'a list --> {n' + 1} 'a list

val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using $(m + 2) * $n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end

(* The following is the thought process of evoluting [map] from using precise time spec to using big-O time spec.
*)

(* rewrite the time spec equivalently using a function-sort index [g] introduced by [absidx] *)
absidx g : Fun 2 = fn m n => $(m + 2) * $n with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end

(* refine [g]'s sort from [Fun 2] to [{g : Fun 2 | g O (fn m n => $m * $n)}], specifying that [g] must be of Big-O class O(m*n)  *)
absidx g : {g : Fun 2 | g O (fn m n => $m * $n)} = fn m n => $(m + 2) * $n with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end
      
(* sort [{g : Fun 2 | g O (fn m n => $m * $n)}] can be written as [BigO 2 (fn m n => $m * $n)] as a syntax sugar *)
absidx g : BigO 2 (fn m n => $m * $n) = fn m n => $(m + 2) * $n with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end

(* now the magic: [g]'s definition can be inferred! *)
absidx g : BigO 2 (fn m n => $m * $n) = _ with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end

(* [= _] in [absidx] can be omitted as a syntax sugar *)
absidx g : BigO 2 (fn m n => $m * $n) with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end

(* the magic goes further: even [g]'s BigO class can be inferred! *)
absidx g : BigO 2 _ with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end
      
val ['a] ['b] foldl =
 fn {m : Nat} (f : 'a * 'b -- $m --> 'b) =>
    let
        fun foldl {n : Nat} (y : _, xs : {n} _ list) return _ using $(m + 2) * $n =
            case xs of
                Nil => y
              | Cons {n'} (x, xs) => foldl {_} (f (x, y), xs)
    in
        foldl
    end

absidx h : BigO 2 _ with
val ['a] ['b] foldl =
 fn {m : Nat} (f : 'a * 'b -- $m --> 'b) =>
    let
        fun foldl {n : Nat} (y : _, xs : {n} _ list) return _ using h m n =
            case xs of
                Nil => y
              | Cons {n'} (x, xs) => foldl {_} (f (x, y), xs)
    in
        foldl
    end
end

fun ['a] split {n : Nat} (xs : {n} 'a list) return {ceil ($n/2)} _ list * {floor ($n/2)} _ list using $n =
    case xs of
        Nil => (Nil, Nil)
      | Cons {_} (x, Nil) => (xs, Nil)
      | Cons {_} (x1, Cons {_} (x2, xs)) =>
        case split {_} xs of
            (xs1, xs2) => (Cons {_} (x1, xs1), Cons {_} (x2, xs2))
                              
datatype bool = true | false

absidx f : {f : Fun 2 | f O _} with
fun ['a] merge {m : Nat} (le : 'a * 'a -- $m --> bool) return using 0.0 =
    let
      fun merge {n1 : Nat} {n2 : Nat} ((xs, ys) : {n1} _ list * {n2} _ list) return {n1 + n2} _ list using f m (n1 + n2) =
          case (xs, ys) of
              (Nil, _) => ys
            | (_, Nil) => xs
            | (Cons {n1'} (x, xs'), Cons {n2'} (y, ys')) =>
              case le (x, y) return using 1.0 + f m (n1' + n2' + 1) of
                  true => Cons {_} (x, merge {_} {_} (xs', ys))
                | false => Cons {_} (y, merge {_} {_} (xs, ys'))
    in
      merge
    end
end

absidx {T : Fun 2 | T O _} with
fun ['a] msort {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs of
              Nil => xs
            | (Cons {_} (_, Nil)) => xs
            | (Cons {n1} (_, Cons {n2} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
      sort
    end
end

absidx {T : Fun 2 | T O (fn m n => $m * $n * log2 $n)} with
fun ['a] msort {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs of
              Nil => xs
            | (Cons {_} (_, Nil)) => xs
            | (Cons {n1} (_, Cons {n2} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
      sort
    end
end

