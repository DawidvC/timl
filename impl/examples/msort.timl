datatype {Nat} 'a list =
         Nil of unit --> {0} 'a list
         | Cons {n' : Nat} of 'a * {n'} 'a list --> {n' + 1} 'a list

val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using $(m + 2) * $n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end

(*      
  The following is the thought process of evoluting [map] from using precise time spec to using big-O time spec

idx g : Fun 2 = fn m n => $(m + 2) * $n
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls return {n} _ list using g m n of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end

idx g : {g : Fun 2 | g O (fn m n => $m * $n)} = fn m n => $(m + 2) * $n
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls return {n} _ list using g m n of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
      
idx g : {g : Fun 2 | g O (fn m n => $m * $n)} = _
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls return {n} _ list using g m n of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
      
absidx g : {g : Fun 2 | g O (fn m n => $m * $n)} = _ with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls return {n} _ list using g m n of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end

absidx g : {g : Fun 2 | g O _} = _ with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls return {n} _ list using g m n of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end
*)

absidx g : {g : Fun 2 | g O _} with
val ['a] ['b] map =
 fn {m : Nat} (f : 'a -- $m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} _ list) return {n} _ list using g m n =
            case ls of
                Nil => Nil
              | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
        map
    end
end
      
val ['a] ['b] foldl =
 fn {m : Nat} (f : 'a * 'b -- $m --> 'b) =>
    let
        fun foldl {n : Nat} (y : _, xs : {n} _ list) return _ using $(m + 2) * $n =
            case xs of
                Nil => y
              | Cons {n'} (x, xs) => foldl {_} (f (x, y), xs)
    in
        foldl
    end

absidx h : {h : Fun 2 | h O _} with
val ['a] ['b] foldl =
 fn {m : Nat} (f : 'a * 'b -- $m --> 'b) =>
    let
        fun foldl {n : Nat} (y : _, xs : {n} _ list) return _ using h m n =
            case xs of
                Nil => y
              | Cons {n'} (x, xs) => foldl {_} (f (x, y), xs)
    in
        foldl
    end
end

fun ['a] split {n : Nat} (xs : {n} 'a list) return {ceil ($n/2)} _ list * {floor ($n/2)} _ list using $n =
    case xs of
        Nil => (Nil, Nil)
      | Cons {_} (x, Nil) => (xs, Nil)
      | Cons {_} (x1, Cons {_} (x2, xs)) =>
        case split {_} xs of
            (xs1, xs2) => (Cons {_} (x1, xs1), Cons {_} (x2, xs2))
                              
datatype bool = true | false

absidx f : {f : Fun 2 | f O _} with
fun ['a] merge {m : Nat} (le : 'a * 'a -- $m --> bool) return using 0.0 =
    let
      fun merge {n1 : Nat} {n2 : Nat} ((xs, ys) : {n1} _ list * {n2} _ list) return {n1 + n2} _ list using f m (n1 + n2) =
          case (xs, ys) of
              (Nil, _) => ys
            | (_, Nil) => xs
            | (Cons {n1'} (x, xs'), Cons {n2'} (y, ys')) =>
              case le (x, y) return using 1.0 + f m (n1' + n2' + 1) of
                  true => Cons {_} (x, merge {_} {_} (xs', ys))
                | false => Cons {_} (y, merge {_} {_} (xs, ys'))
    in
      merge
    end
end

absidx {T : Fun 2 | T O _} with
fun ['a] msort {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs of
              Nil => xs
            | (Cons {_} (_, Nil)) => xs
            | (Cons {n1} (_, Cons {n2} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
      sort
    end
end

absidx {T : Fun 2 | T O (fn m n => $m * $n * log2 $n)} with
fun ['a] msort {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs of
              Nil => xs
            | (Cons {_} (_, Nil)) => xs
            | (Cons {n1} (_, Cons {n2} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
      sort
    end
end

