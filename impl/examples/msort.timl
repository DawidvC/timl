structure MSort = struct
open Basic
open List

absidx T_split: BigO 1 _ (* (fn n => $n) *) = _ with
fun split ['a] {n: Nat} (xs: {n} 'a list) return {ceil ($n/2)} 'a list * {floor ($n/2)} 'a list using T_split n =
    case xs of
        [] => ([], [])
      | [x] => (xs, [])
      | x1 :: x2 :: xs =>
        let val (xs1, xs2) = split xs in
        (x1 :: xs1, x2 :: xs2) end
end

absidx T_merge: BigO 2 (fn m n => $m * $n) = _ with
fun merge ['a] {m n1 n2: Nat} (le: 'a*'a --$m--> bool) (xs: {n1} 'a list, ys: {n2} 'a list) return {n1 + n2} 'a list using T_merge m (n1 + n2) =
    case (xs, ys) of
        ([], _) => ys
      | (_, []) => xs
      | (x :: xs', y :: ys') =>
        if le (x, y) then x :: merge le (xs', ys)
        else y :: merge le (xs, ys')
end


absidx {T : Fun 2 | T O (fn m n => $m * $n * log2 $n)(* _ *)} with
fun msort ['a] {m : Nat} {n : Nat} (le : 'a * 'a -- $m --> bool) (xs : {n} (* _ *)'a list) return {n} (* _ *)'a list using T m n =
    case xs of
        Nil => xs
      | (Cons (_, Nil)) => xs
      | (Cons (_, Cons (_, _))) =>
        case split xs of
            (xs1, xs2) => merge le (msort le xs1, msort le xs2)
end

absidx g : BigO 1 (fn n => $n) = fn n => 2.0 * $n with
fun revAppend ['a] {n1 : Nat} (xs : {n1} 'a list) {n2 : Nat} (ys : {n2} 'a list) return {n1 + n2} (* _ *)'a list using g n1 =
    case xs of
        Nil => ys
      | Cons (x, xs) => revAppend xs {_} (Cons (x, ys))
end

absidx T_revAppend : BigO 1 (fn n => $n) (* = fn n => 2.0 * $n *) with
fun revAppend ['a] {n1 n2 : Nat} (xs : {n1} 'a list) (ys : {n2} 'a list) return {n1 + n2} 'a list using T_revAppend n1 =
    case xs of
        [] => ys
      | x :: xs => revAppend xs (x :: ys)
end

absidx g : BigO 1 (fn n => $n) with
fun rev ['a] {n : Nat} (xs : {n} 'a list) return {n} _ list using g n = revAppend xs Nil
end

absidx T: BigO 2 (fn m n => $m*$n*log2 $n) = _
                                               
fun msort ['a] {m n: Nat} (le: 'a*'a --$m--> bool) (xs: {n} 'a list) return {n} 'a list using T m n =
    case xs of
        [] => xs
      | [_] => xs
      | _ :: _ :: _ =>
        let val (xs1, xs2) = split xs in
          merge le (msort le xs1, msort le xs2) end

end
