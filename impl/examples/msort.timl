fun split ['a] {n : Nat} (xs : {n} 'a list) return {ceil ($n/2)} _ list * {floor ($n/2)} _ list using $n =
    case xs of
        Nil => (Nil, Nil)
      | Cons {_} (x, Nil) => (xs, Nil)
      | Cons {_} (x1, Cons {_} (x2, xs)) =>
        case split {_} xs of
            (xs1, xs2) => (Cons {_} (x1, xs1), Cons {_} (x2, xs2))

absidx f : {f : Fun 2 | f O _} with
fun merge ['a] {m : Nat} (le : 'a * 'a -- $m --> bool) return using 0.0 =
    let
      fun merge {n1 : Nat} {n2 : Nat} ((xs, ys) : {n1} _ list * {n2} _ list) return {n1 + n2} _ list using f m (n1 + n2) =
          case (xs, ys) of
              (Nil, _) => ys
            | (_, Nil) => xs
            | (Cons {n1'} (x, xs'), Cons {n2'} (y, ys')) =>
              case le (x, y) (* return using 1.0 + f m (n1' + n2' + 1) *) of
                  true => Cons {_} (x, merge {_} {_} (xs', ys))
                | false => Cons {_} (y, merge {_} {_} (xs, ys'))
    in
      merge
    end
end

absidx {T : Fun 2 | T O _} with
fun msort ['a] {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs of
              Nil => xs
            | (Cons {_} (_, Nil)) => xs
            | (Cons {n1} (_, Cons {n2} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
      sort
    end
end

absidx {T : Fun 2 | T O (fn m n => $m * $n * log2 $n)} with
fun msort ['a] {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs of
              Nil => xs
            | (Cons {_} (_, Nil)) => xs
            | (Cons {n1} (_, Cons {n2} (_, _))) =>
              case split {n} xs of
                  (xs1, xs2) => merge {_} le {_} {_} (sort {_} xs1, sort {_} xs2)
    in
      sort
    end
end

absidx g : BigO 1 (fn n => $n) = fn n => 2.0 * $n with
fun revAppend ['a] {n1 : Nat} (xs : {n1} 'a list) {n2 : Nat} (ys : {n2} 'a list) return {n1 + n2} _ list using g n1 =
    case xs of
        Nil => ys
      | Cons {_} (x, xs) => revAppend {_} xs {_} (Cons {_} (x, ys))
end

absidx g : BigO 1 (fn n => $n) with
fun rev ['a] {n : Nat} (xs : {n} 'a list) return {n} _ list using g n = revAppend {_} xs {_} Nil
end

