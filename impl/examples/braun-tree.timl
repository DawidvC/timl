datatype {Nat} 'a braun_tree =
         Leaf of {0} 'a braun_tree
       | Node {n : Nat} of 'a * {ceil ($n/2)} 'a braun_tree * {floor ($n/2)} 'a braun_tree --> {n+1} 'a braun_tree

fun le ['a] (x : 'a, y : 'a) = false using 7.0

fun min_max ['a] {m : Time} (le : 'a * 'a -- m --> bool) (x, y) =
    case le (x, y) of
        true => (x, y)
      | false => (y, x)

absidx Tinsert : BigO 1 (fn n => log2 $n) with
fun insert ['a] {n : Nat} (tr : {n} 'a braun_tree) x return {n + 1} 'a braun_tree using Tinsert n =
    case tr of
        Leaf => Node (x, Leaf, Leaf)
      | @Node {n'} (y, l, r) =>
        let
          val (smaller, bigger) = min_max le (x, y)
        in
          @Node {n' + 1} (smaller, insert r bigger, l)
        end
end

fun peek ['a] {n : Nat} (tr : {n + 1} 'a braun_tree) =
    case tr of
        Node (x, _, _) => x
      | Leaf => never

absidx T : Time with
fun peek_option ['a] {n : Nat} (tr : {n} 'a braun_tree) return 'a option using T =
    case tr of
        Leaf => NONE
      | Node (x, _, _) => SOME x
end

absidx Tsift : BigO 1 _ with
fun sift ['a] {n : Nat} (x, l : {ceil ($n/2)} 'a braun_tree, r : {floor ($n/2)} 'a braun_tree) return {n} 'a braun_tree =
    case (l, r) of
        (Leaf, Leaf) => Node (x, Leaf, Leaf)
      | (Node (y, _, _), Leaf) =>
        let
          val (smaller, bigger) = min_max le (x, y)
        in
          Node (smaller, @Node {0} (bigger, Leaf, Leaf), Leaf)
        end
      | (@Node {nl'} (lx, l1, l2), @Node {nr'} (rx, r1, r2)) =>
        (case (le (x, lx), le (x, rx), le (lx, rx)) of
             (true, true, _) =>
             Node (x, l, r)
           | (_, _, true) =>
             Node (lx, sift (x, l1, l2), r)
           | (_, _, _) =>
             Node (rx, l, sift (x, r1, r2))
        )
      | _ => never
end
                    
absidx Tpop : BigO 1 _ with
fun pop ['a] {n : Nat} (tr : {n + 1} 'a braun_tree) return 'a * {n} 'a braun_tree using Tpop n =
    case tr of
        Node (x, l, r) =>
        (case (l, r) of
             (Leaf, Leaf) => (x, Leaf)
           | (Node (y, _, _), Leaf) =>
             (x, @Node {0} (y, Leaf, Leaf))
           | (@Node {nl'} (lx, _, _), @Node {nr'} (rx, r1, r2)) =>
             let
               val (_, l) = @pop {nl'} l
             in
               case le (lx, rx) of
                   true =>
                   (x, @Node {nl'+1+nr'} (lx, r, l))
                 | false =>
                   (x, @Node {nl'+1+nr'} (rx, sift (lx, r1, r2), l))
             end
           | _ => never
        )
      | Leaf => never
end

