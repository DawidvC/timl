structure BraunTree = struct
open Bool

datatype {Nat} 'a braun_tree =
         Leaf of {0} 'a braun_tree
       | Node {size : Nat} of 'a * {ceil ($size/2)} 'a braun_tree * {floor ($size/2)} 'a braun_tree --> {size+1} 'a braun_tree

fun le ['a] (x : 'a, y : 'a) = false using 7.0

fun min_max ['a] {m : Time} (le : 'a * 'a -- m --> bool) (x, y) =
    case le (x, y) of
        true => (x, y)
      | false => (y, x)

absidx Tinsert : BigO 1 (fn n => log2 $n) with
fun insert ['a] {size : Nat} (tr : {size} 'a braun_tree) x return {size + 1} 'a braun_tree using Tinsert size =
    case tr of
        Leaf => @Node {0} (x, Leaf, Leaf)
      | @Node {size'} (y, l, r) =>
        let
          val (smaller, bigger) = min_max le (x, y)
        in
          @Node {size' + 1} (smaller, insert r bigger, l)
        end
end

fun peek ['a] {size : Nat} (tr : {size + 1} 'a braun_tree) =
    case tr of
        Node (x, _, _) => x
      | Leaf => never

absidx T : Time with
fun peek_option ['a] {size : Nat} (tr : {size} 'a braun_tree) return 'a option using T =
    case tr of
        Leaf => NONE
      | Node (x, _, _) => SOME x
end

absidx Tsift : BigO 1 (fn n => log2 $n)(* _ *) with
fun sift ['a] {size : Nat} (x, l : {ceil ($size/2)} 'a braun_tree, r : {floor ($size/2)} 'a braun_tree) return {size+1} 'a braun_tree using Tsift size =
    case (l, r) of
        (Leaf, Leaf) =>
        @Node {0} (x, Leaf, Leaf)
      | (Node (y, _, _), Leaf) =>
        let
          val (smaller, bigger) = min_max le (x, y)
        in
          @Node {1} (smaller, @Node {0} (bigger, Leaf, Leaf), Leaf)
        end
      | (@Node {nl'} (lx, l1, l2), @Node {nr'} (rx, r1, r2)) =>
        (case (le (x, lx), le (x, rx), le (lx, rx)) of
             (true, true, _) =>
             @Node {size} (x, l, r)
           | (_, _, true) =>
             @Node {size} (lx, @sift {nl'} (x, l1, l2), r)
           | (_, _, _) =>
             @Node {size} (rx, l, @sift {nr'} (x, r1, r2))
        )
      | _ => never
end

absidx Tpop : BigO 1 (fn n => log2 $n * log2 $n)(* _ *) with
fun pop ['a] {size : Nat} (tr : {size + 1} 'a braun_tree) return 'a * {size} 'a braun_tree using Tpop size =
    case tr of
        Node (x, l, r) =>
        (case (l, r) of
             (Leaf, Leaf) => (x, Leaf)
           | (Node (y, _, _), Leaf) =>
             (x, @Node {0} (y, Leaf, Leaf))
           | (@Node {nl'} (lx, _, _), @Node {nr'} (rx, r1, r2)) =>
             let
               val (_, l) = @pop {nl'} l
             in
               case le (lx, rx) of
                   true =>
                   (x, @Node {nl'+1+nr'} (lx, r, l))
                 | false =>
                   (x, @Node {nl'+1+nr'} (rx, @sift {nr'} (lx, r1, r2), l))
             end
           | _ => never
        )
      | Leaf => never
end

end
