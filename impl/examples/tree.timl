datatype {Nat} 'a tree =
         Leaf of {0} 'a tree
       | Node {n1 : Nat} {n2 : Nat} of 'a * {n1} 'a tree * {n2} 'a tree --> {n1 + 1 + n2} 'a tree

fun map_tree ['a 'b] {m : Time} (f : 'a -- m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using (m + 3.0) * $n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end

absidx g : Fun 2 = fn m n => $(m + 3) * $n with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using g m n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) = fn m n => $(m + 3) * $n with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using g m n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using g m n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun tree_foldmlr ['a 'b] {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : {n} _ tree) return using g m n =
          case tr of
              Leaf => acc
            | Node {n1 n2} (x, tr1, tr2) =>
              let
                val acc = f (x, acc)
                val acc = fold acc tr1
                val acc = fold acc tr2
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun tree_foldrlm ['a 'b] {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : {n} _ tree) return using g m n =
          case tr of
              Leaf => acc
            | Node {n1 n2} (x, tr1, tr2) =>
              let
                val acc = fold acc tr2
                val acc = fold acc tr1
                val acc = f (x, acc)
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 1 (fn n => $n) (* = fn n => $(4 * n) *) with
fun tree_append_rlm (* ['a]  *){n : Nat} (tr : {n} (* 'a *)_ tree) {n2 : Nat} (ls : {n2} _ list) return {n + n2} _ list using g n =
    case tr of
        Leaf => ls
      | Node {n1 n2} (x (* : 'a *), tr1, tr2) =>
        let
          val ls = tree_append_rlm tr2 {_} ls
          val ls = tree_append_rlm tr1 {_} ls
          val ls = Cons (x, ls)
        in
          ls
        end
end

absidx g : BigO 1 (fn n => $n) with
fun tree_flatten_mlr (* ['a] *) {n : Nat} (tr : {n} _ tree) return {n} _ list using g n =
    tree_append_rlm tr {_} Nil
end

datatype {Nat} 'a braun_tree =
         BraunLeaf of {0} 'a braun_tree
       | BraunNode {n : Nat} of 'a * {ceil ($n/2)} 'a braun_tree * {floor ($n/2)} 'a braun_tree --> {n+1} 'a braun_tree

absidx g : BigO 1 (fn n => log2 $n) with
fun braun_insert ['a] x {n : Nat} (tr : {n} 'a braun_tree) return {n + 1} 'a braun_tree using g n =
    case tr of
        BraunLeaf => BraunNode (x, BraunLeaf, BraunLeaf)
      | BraunNode {n'} (y, l, r) => @BraunNode {n' + 1} (x, braun_insert y {_} r, l)
end
