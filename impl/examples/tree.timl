datatype {Nat} 'a tree =
         Leaf of {0} 'a tree
       | Node {n1 : Nat} {n2 : Nat} of 'a * {n1} 'a tree * {n2} 'a tree --> {n1 + 1 + n2} 'a tree

fun ['a] ['b] map_tree {m : Time} (f : 'a -- m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using (m + 3.0) * $n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node {_} {_} (f x, map {_} tr1, map {_} tr2)
    in
      map
    end

absidx g : Fun 2 = fn m n => $(m + 3) * $n with
fun ['a] ['b] map_tree {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using g m n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node {_} {_} (f x, map {_} tr1, map {_} tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) = fn m n => $(m + 3) * $n with
fun ['a] ['b] map_tree {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using g m n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node {_} {_} (f x, map {_} tr1, map {_} tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun ['a] ['b] map_tree {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} _ tree) return {n} _ tree using g m n =
          case tr of
              Leaf => Leaf
            | Node {n1 n2} (x, tr1, tr2) => Node {_} {_} (f x, map {_} tr1, map {_} tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun ['a] ['b] tree_foldmlr {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : {n} _ tree) return _ using g m n =
          case tr of
              Leaf => acc
            | Node {n1 n2} (x, tr1, tr2) =>
              let
                val acc = f (x, acc)
                val acc = fold {_} acc tr1
                val acc = fold {_} acc tr2
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun ['a] ['b] tree_foldrlm {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : {n} _ tree) return _ using g m n =
          case tr of
              Leaf => acc
            | Node {n1 n2} (x, tr1, tr2) =>
              let
                val acc = fold {_} acc tr2
                val acc = fold {_} acc tr1
                val acc = f (x, acc)
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 1 (fn n => $n) (* = fn n => $(4 * n) *) with
fun tree_append_rlm {n : Nat} (tr : {n} _ tree) {n2 : Nat} (ls : {n2} _ list) return {n + n2} _ list using g n =
    case tr of
        Leaf => ls
      | Node {n1 n2} (x, tr1, tr2) =>
        let
          val ls = tree_append_rlm {_} tr2 {_} ls
          val ls = tree_append_rlm {_} tr1 {_} ls
          val ls = Cons {_} (x, ls)
        in
          ls
        end
end

absidx g : BigO 1 (fn n => $n) with
fun ['a] tree_flatten_mlr {n : Nat} (tr : {n} _ tree) return {n} _ list using g n =
    tree_append_rlm {_} tr {_} Nil
end
