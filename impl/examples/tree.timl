structure Tree = struct
open Bool
open List
       
datatype {Nat} 'a tree =
         Leaf of {0} 'a tree
       | Node {n1 : Nat} {n2 : Nat} of 'a * {n1} 'a tree * {n2} 'a tree --> {n1 + 1 + n2} 'a tree

fun map_tree ['a 'b] {m : Time} (f : 'a -- m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} 'a(* _ *) tree) return {n} 'b(* _ *) tree using (m + 3.0) * $n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end

absidx g : Fun 2 = fn m n => $(m + 3) * $n with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} 'a(* _ *) tree) return {n} 'b(* _ *) tree using g m n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) = fn m n => $(m + 3) * $n with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} 'a(* _ *) tree) return {n} 'b(* _ *) tree using g m n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : {n} 'a(* _ *) tree) return {n} 'b(* _ *) tree using g m n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun tree_foldmlr ['a 'b] {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : {n} 'a(* _ *) tree) return (* _ *)'b using g m n =
          case tr of
              Leaf => acc
            | Node (x, tr1, tr2) =>
              let
                val acc = f (x, acc)
                val acc = fold acc tr1
                val acc = fold acc tr2
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun tree_foldrlm ['a 'b] {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : {n} (* _ *)'a tree) return (* _ *)'b using g m n =
          case tr of
              Leaf => acc
            | Node (x, tr1, tr2) =>
              let
                val acc = fold acc tr2
                val acc = fold acc tr1
                val acc = f (x, acc)
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 1 (fn n => $n) (* = fn n => $(4 * n) *) with
fun tree_append_rlm ['a] {n : Nat} (tr : {n} 'a(* _ *) tree) {n2 : Nat} (ls : {n2} (* _ *)'a list) return {n + n2} (* _ *)'a list using g n =
    case tr of
        Leaf => ls
      | Node (x (* : 'a *), tr1, tr2) =>
        let
          val ls = tree_append_rlm tr2 {_} ls
          val ls = tree_append_rlm tr1 {_} ls
          val ls = Cons (x, ls)
        in
          ls
        end
end

absidx g : BigO 1 (fn n => $n) with
fun tree_flatten_mlr (* ['a] *) {n : Nat} (tr : {n} _ tree) return {n} _ list using g n =
    tree_append_rlm tr {_} Nil
end

end
