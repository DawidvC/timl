datatype {Nat} 'a ilist =
         NilI of unit -> {0} 'a ilist
         | ConsI of {n' : Nat} 'a * {n'} 'a ilist -> {n' + 1} 'a ilist

val map = 
 fn ['a] ['b] {m : Nat} (f : 'a -- m --> 'b) =>
    fix (map : forall {n : Nat}, {n} 'a ilist -- (m + 2) * n --> {n} 'b ilist) {n : Nat} (ls : {n} 'a ilist) =>
    case ls return {n} 'b ilist of
        NilI => NilI ['b]
      | ConsI {n'} (x, xs) => ConsI ['b] {n'} (f x, map {n'} xs) |> (m + 2) * n

val foldl =
 fn ['a] ['b] {m : Nat} (f : 'a * 'b -- m --> 'b) =>
    fix (loop : 'b -- 0 --> forall {n : Nat}, {n} 'a ilist -- (m + 3) * n --> 'b) (y : 'b) {n : Nat} (xs : {n} 'a ilist) =>
    case xs of
        NilI => y
      | ConsI {n'} (x, xs) => loop (f (x, y)) {n'} xs |> (m + 3) * n

datatype {Nat} 'a even_split =
         Even of {n1 : Nat} {n2 : {n2 : Nat | n1 <= n2 + 1 /\ n2 <= n1 + 1}} ({n1} 'a ilist * {n2} 'a ilist) -> {n1 + n2} 'a even_split

val split =
 fn ['a] =>
    fix (split : forall {n : Nat}, {n} 'a ilist -- n --> {n} 'a even_split) {n : Nat} (xs : {n} 'a ilist) =>
    case xs return {n} 'a even_split |> n of
        NilI => Even ['a] {0} {0} (NilI ['a], NilI ['a])
      | ConsI {_} (x, NilI) => Even ['a] {1} {0} (xs, NilI ['a])
      | ConsI {_} (x1, (ConsI {n'} (x2, xs))) =>
        (case split {n'} xs return {n} 'a even_split of
             Even {n1 n2} (xs1, xs2) => Even ['a] {n1 + 1} {n2 + 1} (ConsI ['a] {n1} (x1, xs1), ConsI ['a] {n2} (x2, xs2)))

datatype bool = true | false

val merge =
 fn ['a] {m : Nat} (le : 'a * 'a -- m --> bool) =>
    fix (merge : forall {n1 : Nat} {n2 : Nat}, {n1} 'a ilist -- 0 --> {n2} 'a ilist -- (m + 3) * (n1 + n2) --> {n1 + n2} 'a ilist) {n1 : Nat} {n2 : Nat} (xs : {n1} 'a ilist) (ys : {n2} 'a ilist) =>
    case (xs, ys) return {n1 + n2} 'a ilist |> (m + 3) * (n1 + n2) of
        (NilI, _) => ys
      | (_, NilI) => xs
      | (ConsI {n1'} (x, xs'), ConsI {n2'} (y, ys')) =>
        case le (x, y) of
            true => ConsI ['a] {n1' + n2} (x, merge {n1'} {n2} xs' ys)
          | false => ConsI ['a] {n1 + n2'} (y, merge {n1} {n2'} xs ys')

val msort =
 fn ['a] {m : Nat} (le : 'a * 'a -- m --> bool) =>
    fix (sort : forall {n : Nat}, {n} 'a ilist -- m * n (* just a placeholder*) --> {n} 'a ilist) {n : Nat} (xs : {n} 'a ilist) =>
    case xs return {n} 'a ilist of
        NilI => xs
      | (ConsI {_} (_, NilI)) => xs
      | (ConsI {_} (_, ConsI {_} (_, _))) =>
        case split ['a] {n} xs return {n} 'a ilist |> m * n of
            Even {n1 n2} (xs1, xs2) => merge ['a] {m} le {n1} {n2} (sort {n1} xs1) (sort {n2} xs2)

