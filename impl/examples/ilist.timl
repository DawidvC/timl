datatype {Nat} 'a ilist =
         NilI of unit -> {0} 'a ilist
         | ConsI of {n' : Nat} 'a * {n'} 'a ilist -> {n' + 1} 'a ilist

val map = 
 fn ['a] ['b] {m : Time} (f : 'a -- m --> 'b) =>
    fix map {n : Nat} (ls : {n} 'a ilist) : {n} 'b ilist |> (m + 2.0) * $n =>
    case ls return {n} 'b ilist of
        NilI => NilI ['b]
      | ConsI {n'} (x, xs) => ConsI ['b] {n'} (f x, map {n'} xs) |> (m + 2.0) * $n

val foldl =
 fn ['a] ['b] {m : Time} (f : 'a * 'b -- m --> 'b) =>
    fix loop {n : Nat} ((y, xs) : 'b * {n} 'a ilist) : 'b |> (m + 2.0) * $n =>
    case xs of
        NilI => y
      | ConsI {n'} (x, xs) => loop {n'} (f (x, y), xs) |> (m + 2.0) * $n

datatype {Nat} 'a even_split =
         Even of {n1 : Nat} {n2 : Nat | n2 <= n1 /\ n1 <= n2 + 1} ({n1} 'a ilist * {n2} 'a ilist) -> {n1 + n2} 'a even_split

val split =
 fn ['a] =>
    fix split {n : Nat} (xs : {n} 'a ilist) : {n} 'a even_split |> $n =>
    case xs return {n} 'a even_split |> $n of
        NilI => Even ['a] {0} {0} (NilI ['a], NilI ['a])
      | ConsI {_} (x, NilI) => Even ['a] {1} {0} (xs, NilI ['a])
      | ConsI {_} (x1, (ConsI {n'} (x2, xs))) =>
        (case split {n'} xs return {n} 'a even_split of
             Even {n1 n2} (xs1, xs2) => Even ['a] {n1 + 1} {n2 + 1} (ConsI ['a] {n1} (x1, xs1), ConsI ['a] {n2} (x2, xs2)))

datatype bool = true | false

val merge =
 fn ['a] {m : Time} (le : 'a * 'a -- m --> bool) =>
    fix merge {n1 : Nat} {n2 : Nat} ((xs, ys) : {n1} 'a ilist * {n2} 'a ilist) : {n1 + n2} 'a ilist |> (m + 2.0) * $(n1 + n2) =>
    case (xs, ys) return {n1 + n2} 'a ilist |> (m + 2.0) * $(n1 + n2) of
        (NilI, _) => ys
      | (_, NilI) => xs
      | (ConsI {n1'} (x, xs'), ConsI {n2'} (y, ys')) =>
        case le (x, y) of
            true => ConsI ['a] {n1' + n2} (x, merge {n1'} {n2} (xs', ys))
          | false => ConsI ['a] {n1 + n2'} (y, merge {n1} {n2'} (xs, ys'))

val msort =
 fn ['a] {m : Time} (le : 'a * 'a -- m --> bool) =>
    fix sort {n : Nat} (xs : {n} 'a ilist) : {n} 'a ilist |> (m + 3.0) * 4.0 * $n * log2 $n =>
    case xs return {n} 'a ilist of
        NilI => xs
      | (ConsI {_} (_, NilI)) => xs
      | (ConsI {_} (_, ConsI {_} (_, _))) =>
        case split ['a] {n} xs return {n} 'a ilist |> (m + 3.0) * 4.0 * $n * log2 $n - $(1 + n) of
            Even {n1} {n2} (xs1, xs2) => merge ['a] {m} le {n1} {n2} (sort {n1} xs1, sort {n2} xs2)

(* package to big-O spec *)
val merge_sort =
 fn ['a] =>
    pack [exists {c : {c : Time | c > 0.0}}, forall {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a ilist -- (m + 3.0) * c * $n * log2 $n --> {n} 'a ilist] {4.0} (msort ['a])

(*

exists {c : Time} {ub : Time}, forall {n : Nat}, {n} 'a list -- max ub (c * $n * log2 $n) --> {n} 'a list

exists {c : BigOConsts}, forall {n : Nat}, {n} 'a list -- O c ($n * log2 $n) --> {n} 'a list

exists {g : O (n => $n * log2 $n)}, forall {n : Nat}, {n} 'a list -- g n --> {n} 'a list

==========================
O (ub1,c1) (n * log n) + O (ub2,c2) n <= O ((ub1+ub2)/c2+1.73,c1+1.0) (n * log n)

==========================
exists c, O c1 (n * log n) + O c2 n <= O c (n * log n)

idx c1

idx c2

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a ilist -- O c1 m * O c2 ($n * log2 $n) --> {n} 'a ilist

<->

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a ilist -- O m * O ($n * log2 $n) --> {n} 'a ilist

==========================
exists c, O c1 n + O c2 n + O c3 1 <= O c n

*)
         
