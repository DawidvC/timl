fun add (a : int) (b : int) = a + b

val add : int -- 0.0 --> int -- 1.0 --> int = fn (a : int) (b : int) => a + b

fun add (a : int) (b : int) return using 1.0 = a + b

fun add (a : int) (b : int) = a + b using 1.0
                                    
(* datatype 'a list = *)
(*          Nil *)
(*        | Cons of 'a * 'a list *)

datatype {Nat} 'a list =
         Nil of unit -> {0} 'a list
       | Cons {n : Nat} of 'a * {n} 'a list -> {n + 1} 'a list
                                                       
(* fun map f xs = *)
(*     case xs of *)
(*         Nil => Nil *)
(*       | Cons (x, xs) => Cons (f x, map f xs) *)

(* fun map f = *)
(*     let *)
(*       fun map xs = *)
(*           case xs of *)
(*               Nil => Nil *)
(*             | Cons (x, xs) => Cons (f x, map xs) *)
(*     in *)
(*       map *)
(*     end *)

fun ['a] ['b] map {m : Time} (f : 'a -- m --> 'b) =
    let
      fun map {n : Nat} (xs : {n} 'a list) return {n} 'b list using (m + 2.0) * $n =
          case xs return {n} 'b list using (m + 2.0) * $n of
              Nil => Nil
            | Cons {n'} (x, xs) => Cons {n'} (f x, map {n'} xs)
    in
      map
    end
      
fun ['a] ['b] map {m : Time} (f : 'a -- m --> 'b) =
    let
      fun map {n : Nat} (xs : {n} _ list) return {n} _ list using (m + 2.0) * $n =
          case xs return {n} _ list using (m + 2.0) * $n of
              Nil => Nil
            | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs)
    in
      map
    end

(* idx T : Fun 2 = fn m n => ($m + 2.0) * $n *)
(* fun ['a] ['b] map {m : Nat} (f : 'a -- $m --> 'b) = *)
(*     let *)
(*       fun map {n : Nat} (xs : {n} _ list) return {n} _ list using T m n = *)
(*           case xs return {n} _ list using T m n of *)
(*               Nil => Nil *)
(*             | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs) *)
(*     in *)
(*       map *)
(*     end *)
      
(* idx T : {T : Fun 2 | T O (fn m n => $m * $n)} = fn m n => ($m + 2.0) * $n *)
(* fun ['a] ['b] map {m : Nat} (f : 'a -- $m --> 'b) = *)
(*     let *)
(*       fun map {n : Nat} (xs : {n} _ list) return {n} _ list using T m n = *)
(*           case xs return {n} _ list using T m n of *)
(*               Nil => Nil *)
(*             | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs) *)
(*     in *)
(*       map *)
(*     end *)
      
(* absidx T : {T : Fun 2 | T O (fn m n => $m * $n)} = fn m n => ($m + 2.0) * $n with *)
(* fun ['a] ['b] map {m : Nat} (f : 'a -- $m --> 'b) = *)
(*     let *)
(*       fun map {n : Nat} (xs : {n} _ list) return {n} _ list using T m n = *)
(*           case xs return {n} _ list using T m n of *)
(*               Nil => Nil *)
(*             | Cons {n'} (x, xs) => Cons {_} (f x, map {_} xs) *)
(*     in *)
(*       map *)
(*     end *)
(* end *)

absidx {T : Fun 2 | T O _} with
fun ['a] ['b] map {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (xs : {n} _ list) return {n} _ list using T m n =
          case xs return {n} _ list using T m n of
              Nil => Nil
            | Cons {_} (x, xs) => Cons {_} (f x, map {_} xs)
    in
      map
    end
end

fun ['a] split {n : Nat} (xs : {n} 'a list) return {ceil ($n/2)} _ list * {floor ($n/2)} _ list using $n =
    case xs return {ceil ($n/2)} _ list * {floor ($n/2)} _ list using $n of
        Nil => (Nil, Nil)
      | Cons {_} (x, Nil) => (xs, Nil)
      | Cons {_} (x1, Cons {_} (x2, xs)) =>
        case split {_} xs of
            (xs1, xs2) => (Cons {_} (x1, xs1), Cons {_} (x2, xs2))

datatype bool = true | false

absidx {T2 : Fun 2 | T2 O _} with
fun ['a] merge {m : Nat} (lt : 'a * 'a -- $m --> bool) =
    let
      fun merge {n1 : Nat} {n2 : Nat} (xs : {n1} _ list) (ys : {n2} _ list) return {n1 + n2} _ list using T2 m (n1 + n2) =
          case (xs, ys) return {n1 + n2} _ list using T2 m (n1 + n2) of
              (Nil, _) => ys
            | (_, Nil) => xs
            | (Cons {n1'} (x, xs'), Cons {n2'} (y, ys')) =>
              case lt (x, y) return using 2.0 + T2 m (n1' + n2' + 1) of
                  true => Cons {_} (x, merge {_} {_} xs' ys)
                | false => Cons {_} (y, merge {_} {_} xs ys')
    in
      merge
    end
end

absidx {T3 : Fun 2 | T3 O _} with
fun ['a] msort {m : Nat} (lt : 'a * 'a -- $m --> bool) =
    let
      fun msort {n : Nat} (xs : {n} 'a list) return {n} _ list using T3 m n =
          case xs of
              Nil => xs
            | Cons {_} _ =>
              case split {_} xs of
                  (xs1, xs2) => merge {_} lt {_} {_} (msort {_} xs1) (msort {_} xs2)
    in
      msort
    end
end
