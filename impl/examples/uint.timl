structure Uint = struct

(* some placeholders for indexed unsigned fixed-width integers (they should be provided natively by the language, to support O(1) operations) *)
datatype {Nat} uint =
         (* constructors are just placeholders *)
       (*   Zero of {0} uint *)
(* | Succ {n : Nat} of {n} uint --> {n + 1} uint *)
         UintDummy {n : Nat} of {n} uint
                              
datatype {Nat} {Nat} cmp_result =
         Equal {a b : Nat} {a = b} of {b} {a} cmp_result
         | Less {a b : Nat} {a < b} of {b} {a} cmp_result
         | Greater {a b : Nat} {a > b} of {b} {a} cmp_result

fun cmp {x : Nat} {y : Nat} (x : {x} uint, y : {y} uint) return {y} {x} cmp_result using 7.0 =
    @Equal {x} {y} {admit}

datatype {Nat} {Nat} le_result =
         Le {a b : Nat} {a <= b} of {b} {a} le_result
       | Gt {a b : Nat} {a > b} of {b} {a} le_result

fun le {x : Nat} {y : Nat} (x : {x} uint, y : {y} uint) return {y} {x} le_result using 7.0 =
    @Le {x} {y} {admit}

datatype {Nat} {Nat} min_max_result =
         MinMaxResult {a b a' b' : Nat} {(a <= b -> a' = a /\ b' = b) /\ (a > b -> a' = b /\ b' = a)} of {a'} uint * {b'} uint --> {b} {a} min_max_result

fun min_max {m : Time} {x : Nat} {y : Nat} (le : {x} uint * {y} uint -- m --> {y} {x} le_result) (x : {x} uint, y : {y} uint) return {y} {x} min_max_result =
    case le (x, y) of
        Le => MinMaxResult (x, y)
      | Gt => MinMaxResult (y, x)

datatype {Nat} {Nat} eq_dec =
         Eq {a b : Nat} {a = b} of {b} {a} eq_dec
       | Neq {a b : Nat} {~ (a = b)} of {b} {a} eq_dec

fun eq_dec {x y : Nat} (x : {x} uint, y : {y} uint) return {y} {x} eq_dec using 1.0 =
    @Eq {x} {y} {admit}

datatype {Nat} {Nat} lt_dec =
         Lt {a b : Nat} {a < b} of {b} {a} lt_dec
       | Ge {a b : Nat} {a >= b} of {b} {a} lt_dec

fun lt_dec {x y : Nat} (x : {x} uint, y : {y} uint) return {y} {x} lt_dec using 1.0 =
    @Lt {x} {y} {admit}

fun uint_mult {a b : Nat} (a : {a} uint, b : {b} uint) return {a * b} uint using 1.0 =
    UintDummy

fun uint_max {a b : Nat} (a : {a} uint, b : {b} uint) return {a max b} uint using 1.0 =
    UintDummy

val uint_1 : {1} uint = UintDummy
val uint_2 : {2} uint = UintDummy
val uint_4 : {4} uint = UintDummy

fun floor_half {n : Nat} (n : {n} uint) return {floor ($n / 2)} uint =
    UintDummy

end
