absidx g : BigO 2 (fn m n => $m * $n) with
fun ['a] insert {m : Nat} (le : 'a * 'a -- $m --> bool) x =
    let
      fun insert {n : Nat} (xs : {n} _ list) return {n + 1} _ list using g m n =
          case xs of
              Nil => Cons {_} (x, Nil)
            | Cons {n'} (x', xs') =>
              case le (x, x') return {n + 1} _ list using 1.0 + g m n' of
                  true => Cons {_} (x, xs)
                | false => Cons {_} (x', insert {_} xs')
    in
      insert
    end
end

absidx g : BigO 2 (fn m n => $m * $n * $n) with
fun ['a] insertion_sort {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using g m n =
          case xs of
              Nil => Nil
            | Cons {_} (x, xs) => insert {_} le x {_} (sort {_} xs)
    in
      sort
    end
end
