absidx g : BigO 2 (fn m n => $m * $n) with
fun insert ['a] {m : Nat} (le : 'a * 'a -- $m --> bool) x =
    let
      fun insert {n : Nat} (xs : {n} _ list) return {n + 1} _ list using g m n =
          case xs of
              Nil => Cons (x, Nil)
            | Cons {n'} (x', xs') =>
              case le (x, x') (* return {n + 1} _ list using 1.0 + g m n' *) of
                  true => Cons (x, xs)
                | false => Cons (x', insert xs')
    in
      @insert
    end
end

absidx g : BigO 2 (fn m n => $m * $n * $n) with
fun insertion_sort ['a] {m : Nat} (le : 'a * 'a -- $m --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using g m n =
          case xs of
              Nil => Nil
            | Cons {_} (x, xs) => insert le x {_} (sort xs)
    in
      @sort
    end
end
