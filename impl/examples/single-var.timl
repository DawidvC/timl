absidx gg : {gg : Fun 1 | gg O (fn n => $n)} with
val g =
 fn {n : Nat} (xs : {n} int list) return using gg n => xs
end

absidx hh : {hh : Fun 1 | hh O (fn n => 1.0)} with
val h =
 fn {n : Nat} (xs : {n} int list) return using hh n => xs
end

absidx ff : {ff : Fun 1 | ff O _} with
val f =
 fn {n : Nat} (xs : {n} int list) return using ff n =>
    let
        val xs = g xs
        val xs = h xs
    in
        xs
    end
end

absidx {T : Fun 1 | T O _} with
fun map ['a 'b] (f : 'a -- 5.0 --> 'b) =
    let
      fun map {n : Nat} (xs : {n} 'a list) return {n} _ list using T n =
          case xs of
              Nil => Nil
            | Cons {_} (x, xs) =>
              Cons (f x, map xs)
    in
      map
    end
end      

fun split ['a] {n : Nat} (xs : {n} 'a list) return {ceil ($n/2)} _ list * {floor ($n/2)} _ list using $n =
    case xs of
        Nil => (Nil, Nil)
      | Cons {_} (x, Nil) => (xs, Nil)
      | Cons {_} (x1, Cons {_} (x2, xs)) =>
        case split xs of
            (xs1, xs2) => (Cons (x1, xs1), Cons (x2, xs2))

datatype bool = true | false

absidx {T2 : Fun 1 | T2 O _} with
fun merge ['a] (lt : 'a * 'a -- 8.0 --> bool) =
    let
      fun merge {n1 : Nat} {n2 : Nat} (xs : {n1} _ list) (ys : {n2} _ list) return {n1 + n2} _ list using T2 (n1 + n2) =
          case (xs, ys) of
              (Nil, _) => ys
            | (_, Nil) => xs
            | (Cons {n1'} (x, xs'), Cons {n2'} (y, ys')) =>
              case lt (x, y) (* return using 2.0 + T2 (n1' + n2' + 1) *) of
                  true => Cons (x, merge xs' ys)
                | false => Cons (y, merge xs ys')
    in
      @merge
    end
end

absidx {T3 : Fun 1 | T3 O _} with
fun msort ['a] (lt : 'a * 'a -- _ --> bool) =
    let
      fun msort {n : Nat} (xs : {n} 'a list) return {n} _ list using T3 n =
          case xs of
              Nil => xs
            | Cons {_} _ =>
              case split xs of
                  (xs1, xs2) => merge lt {_} {_} (msort xs1) (msort xs2)
    in
      msort
    end
end

absidx g : BigO 1 (fn n => $n) with
fun insert ['a] (le : 'a * 'a -- 7.0 --> bool) x =
    let
      fun insert {n : Nat} (xs : {n} _ list) return {n + 1} _ list using g n =
          case xs of
              Nil => Cons (x, Nil)
            | Cons {n'} (x', xs') =>
              case le (x, x') return {n + 1} _ list using 1.0 + g n' of
                  true => Cons (x, xs)
                | false => Cons (x', insert xs')
    in
      @insert
    end
end

absidx g : BigO 1 (fn n => $n * $n) with
fun insertion_sort ['a] (le : 'a * 'a -- _ --> bool) =
    let
      fun sort {n : Nat} (xs : {n} _ list) return {n} _ list using g n =
          case xs of
              Nil => Nil
            | Cons {_} (x, xs) => insert le x {_} (sort xs)
    in
      @sort
    end
end
