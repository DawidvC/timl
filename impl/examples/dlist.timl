structure DList =
struct

open Basic
open List
open Array

datatype ref 'a = Ref of {1} 'a array --> 'a ref

fun setref ['a] (r : 'a ref, x : 'a) =
  case r of
      Ref content => update (content, #0, x)

fun deref ['a] (r : 'a ref) =
  case r of
      Ref content => sub (content, #0)

fun newref ['a] (x : 'a) =
  Ref (array (#1, x))

datatype dlist 'a : {Nat} {Nat} =
         DLNil {r : Nat} of {1} {r} 'a dlist --> {0} {1 + r} 'a dlist
       | DRNil {l : Nat} of (({l} {1} 'a dlist) option) ref --> {l + 1} {0} 'a dlist
       | DMid {l r : Nat} of (({l} {r + 2} 'a dlist) option) ref * 'a * {l + 2} {r} 'a dlist --> {l + 1} {r + 1} 'a dlist

absidx T_build_dlist_helper : BigO 1 (fn n => $n) with
fun build_dlist_helper ['a] {l r : Nat} (p : (({l} {r + 1} 'a dlist) option) ref, l : {r} 'a list) return {l + 1} {r} 'a dlist using T_build_dlist_helper r =
  case l of
      [] => DRNil p
    | hd :: tl =>
      let
          val ref_left = newref NONE
          val tl' = build_dlist_helper (ref_left, tl)
          val node = DMid (p, hd, tl')
          val () = setref (ref_left, SOME node)
      in
          node
      end
end

fun build_dlist ['a] {n : Nat} (l : {n} 'a list) =
  let
      val ref_left = newref NONE
      val l' = build_dlist_helper (ref_left, l)
      val node = DLNil l'
      val () = setref (ref_left, SOME node)
  in
      node
  end

absidx T_fold_to_left : BigO 2 (fn m n => $m * $n) with
fun fold_to_left ['a 'b] {m l r : Nat} (f : 'a * 'b -- $m --> 'b) (acc : 'b) (l : {l} {r} 'a dlist) return 'b using T_fold_to_left m l =
  case l of
      DLNil _ => acc
    | DRNil ref_left =>
      let
          val left = deref ref_left
      in
          case left of
              SOME left => fold_to_left f acc left
            | NONE => acc
      end
    | DMid (ref_left, x, _) =>
      let
          val left = deref ref_left
      in
          case left of
              SOME left => fold_to_left f (f (x, acc)) left
            | NONE => acc
      end
end

absidx T_fold_from_left : BigO 2 (fn m n => $m * $n) with
fun fold_from_left ['a 'b] {m l r : Nat} (f : 'a * 'b -- $m --> 'b) (acc : 'b) (l : {l} {r} 'a dlist) return 'b using T_fold_from_left m l =
  case l of
      DLNil _ => acc
    | DRNil ref_left =>
      let
          val left = deref ref_left
      in
          case left of
              SOME left => fold_from_left f acc left
            | NONE => acc
      end
    | DMid (ref_left, x, _) =>
      let
          val left = deref ref_left
      in
          case left of
              SOME left => f (x, fold_from_left f acc left)
            | NONE => acc
      end
end

absidx T_fold_to_right : BigO 2 (fn m n => $m * $n) with
fun fold_to_right ['a 'b] {m l r : Nat} (f : 'a * 'b -- $m --> 'b) (acc : 'b) (l : {l} {r} 'a dlist) return 'b using T_fold_to_right m r =
  case l of
      DLNil right => fold_to_right f acc right
    | DRNil _ => acc
    | DMid (_, x, right) => fold_to_right f (f (x, acc)) right
end

absidx T_fold_from_right : BigO 2 (fn m n => $m * $n) with
fun fold_from_right ['a 'b] {m l r : Nat} (f : 'a * 'b -- $m --> 'b) (acc : 'b) (l : {l} {r} 'a dlist) return 'b using T_fold_from_right m r =
  case l of
      DLNil right => fold_from_right f acc right
    | DRNil _ => acc
    | DMid (_, x, right) => f (x, fold_from_right f acc right)
end

end
