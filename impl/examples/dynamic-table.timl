datatype {Nat} {Nat} 'a table =
         Dummy {size num : Nat} of {num} {size} 'a table

datatype {Nat} {Nat} le =
         LE {a b : Nat} {a <= b} of {b} {a} le

fun table_num_le_size ['a] {size num : Nat} (table : {num} {size} 'a table) return {size} {num} le using 1.0 =
    @LE {} {} {admit}
        
fun alloc ['a] {size : Nat} (size : {size} uint) return {0} {size} 'a table using 1.0 =
    Dummy

(* fun free ['a] {size num : Nat} (table : {num} {size} 'a table) return {0} {0} 'a table using 1.0 = *)
(*     Dummy *)

fun do_insert ['a] {size num : Nat} {num < size} (table : {num} {size} 'a table) (x : 'a) return {num + 1} {size} 'a table using 1.0 =
    Dummy

fun do_delete ['a] {size num : Nat} (table : {num + 1} {size} 'a table) return {num} {size} 'a table =
    Dummy

fun copy ['a] {size num size' num' : Nat} (table : {num} {size} 'a table) (table' : {num'} {size'} 'a table) return {num min size'} {size'} 'a table using $num =
    Dummy

fun num ['a] {size num : Nat} (table : {num} {size} 'a table) return {num} uint using 1.0 =
    UintDummy
      
fun size ['a] {size num : Nat} (table : {num} {size} 'a table) return {size} uint using 1.0 =
    UintDummy
      
datatype {Nat} {Nat} eq_dec =
         Eq {a b : Nat} {a = b} of {b} {a} eq_dec
       | Neq {a b : Nat} {~ (a = b)} of {b} {a} eq_dec

fun eq_dec {x y : Nat} (x : {x} uint, y : {y} uint) return {y} {x} eq_dec using 1.0 =
    @Eq {x} {y} {admit}

fun uint_mult {a b : Nat} (a : {a} uint, b : {b} uint) return {a * b} uint using 1.0 =
    UintDummy

fun uint_max {a b : Nat} (a : {a} uint, b : {b} uint) return {a max b} uint using 1.0 =
    UintDummy

val uint_1 : {1} uint = UintDummy
val uint_2 : {2} uint = UintDummy

datatype {Nat} {Nat} 'a good_table =
         GoodTable {size num : Nat} {size <= 2 * num} of {num} {size} 'a table --> {num} {size} 'a good_table
                                                               
fun insert' ['a] {size num : Nat} (x : 'a) (table : {num} {size} 'a good_table) return {num + 1} {ite (num == size) ((2 * size) max 1) size} 'a good_table using 10.0 + ite (num == size) ($num + 9.0) 1.0 =
    let
      val GoodTable table = table
      val num = num table
      val size = size table
      val LE _ = table_num_le_size table
    in
      case eq_dec (num, size) return using 2.0 + ite (num == size) ($num + 9.0) 1.0 of
          Neq =>
          GoodTable (do_insert table x)
        | Eq =>
          let
            val new_table = alloc (uint_max (uint_mult (size, uint_2), uint_1))
            val new_table = copy table new_table
          in
            GoodTable (do_insert new_table x)
          end
    end

datatype {Time} {Nat} {Nat} {Nat} 'a amortized =
         Amortized {size num size' num' n : Nat} {cost amortized_cost : Time} {cost + $(2 * num') + $size <= $(2 * num) + $size' + amortized_cost * $n} {num' <= num + n} (* {size' <= 1 max (4 * num')} *) of ({num} {size} 'a good_table -- cost --> {num'} {size'} 'a good_table) --> {amortized_cost} {n} {num} {size} 'a amortized
                                                                                                                                                                            
fun insert ['a] {size num : Nat} (x : 'a) return {21.0} {1} {num} {size} 'a amortized =
    Amortized (insert' x)

fun id x = x

fun compose ['a 'b 'c] {T_g T_f : Time} (g : 'b -- T_g --> 'c) (f : 'a -- T_f --> 'b) x =
    g (f x)
    
fun insert_seq' ['a] {n size num : Nat} (xs : {n} 'a list) return {23.0} {n} {num} {size} 'a amortized using 5.0 * $n =
    case xs of
        Nil => Amortized id
      | Cons (x, xs) =>
        let
          val @Amortized {_ _ size' num' _ _ _ _ _} insert = @insert {size} {num} x
          val Amortized insert_seq' = @insert_seq' {} {size'} {num'} xs
        in
          Amortized (compose insert_seq' insert)
        end
                                             
datatype 'a some_good_table =
         SomeGoodTable {size num : Nat} of {num} {size} 'a good_table --> 'a some_good_table

fun insert_seq ['a] {n size num : Nat} {2 * num <= n + size} (xs : {n} 'a list) (table : {num} {size} 'a good_table) return 'a some_good_table using 40.0 * $n =
    let
      val GoodTable _ = table
      val Amortized insert_seq' = @insert_seq' {} {size} {num} xs
      val table = insert_seq' table
      val GoodTable _ = table
    in
      SomeGoodTable table
    end
          
