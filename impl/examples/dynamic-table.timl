functor DynamicTable (structure T : sig
(* size: the number of existing elements in the table 
   capacity: the maximal possible number of elements *)
  type {Nat} {Nat} 'a table
  (* Assumption: for any table, size is not larger than capacity *)
  val table_size_le_capa ['a] : forall {capa size : Nat}, {size} {capa} 'a table -- 1.0 --> {capa} {size} Basic.le
  val alloc ['a] : forall {capa : Nat}, {capa} nat -- 1.0 --> {0} {capa} 'a table
  val do_insert ['a] : forall {capa size : Nat} {size < capa}, {size} {capa} 'a table ->> 'a -- 1.0 --> {size + 1} {capa} 'a table
  datatype {Nat} {Nat} 'a do_delete = DoDelete {capa size size' : Nat} {size = size' \/ size = size' + 1} of {size'} {capa} 'a table --> {size} {capa} 'a do_delete
  val do_delete ['a] : forall {capa size : Nat}, {size} {capa} 'a table ->> 'a -- 1.0 --> {size} {capa} 'a do_delete
  val copy ['a] : forall {capa size capa' size' : Nat}, {size} {capa} 'a table ->> {size'} {capa'} 'a table -- $size --> {size min capa'} {capa'} 'a table
  val size ['a] : forall {capa size : Nat}, {size} {capa} 'a table -- 1.0 --> {size} nat
  val capa ['a] : forall {capa size : Nat}, {size} {capa} 'a table -- 1.0 --> {capa} nat
end) = struct
open T
open Basic
open List
open Nat

(* When size reaches capacity, do re-allocation and copying *)
fun insert' ['a] {capa size : Nat} (x : 'a) (table : {size} {capa} 'a table) return {size + 1} {ite (size == capa) ((2 * capa) max 1) capa} 'a table using 10.0 + ite (size == capa) ($size + 9.0) 1.0 =
    let
      val LE _ = table_size_le_capa table
      val size = size table
      val capa = capa table
    in
      case eq_dec (size, capa) return using 2.0 + ite (size == capa) ($size + 9.0) 1.0 of
          Neq =>
          do_insert table x
        | Eq =>
          let
            val new_table = alloc (nat_max (nat_mult (capa, nat_2), nat_1))
            val new_table = copy table new_table
          in
            do_insert new_table x
          end
    end

datatype {Nat} {Nat} {Nat} {Time} 'a good_cost =
         GoodCost {cost : Time} {capa size size' capa' : Nat}
                  {cost = 4.0 + ite (4 * size' < capa) (5.0 + $size') 0.0}
                  {capa' = ite (4 * size' < capa) (floor ($capa / 2)) capa}
         of {size'} {capa'} 'a table --> {size'} {size} {capa} {cost} 'a good_cost
                                                                      
datatype {Nat} {Nat} 'a delete' =
         Delete' {capa size size' : Nat} {cost : Time} {size = size' \/ size = size' + 1} of (unit -- cost --> {size'} {size} {capa} {cost} 'a good_cost) --> {size} {capa} 'a delete'
                              
fun delete' ['a] {capa size : Nat} (x : 'a) (table : {size} {capa} 'a table) return {size} {capa} 'a delete' =
    let
      val LE _ = table_size_le_capa table
      val @DoDelete {capa _ size _} table = do_delete table x
      val size = size table
      val capa = capa table
    in
      Delete' (
        fn () return {size} {} {} {4.0 + ite (4 * size < capa) (5.0 + $size) 0.0} 'a good_cost =>
           case lt_dec (nat_mult (nat_4, size), capa) return using ite (4 * size < capa) (5.0 + $size) 0.0 of
               Lt =>
               let
                 val new_table = alloc (floor_half capa)
                 val new_table = copy table new_table
               in
                 GoodCost new_table
               end
             | Ge =>
               GoodCost table
      )
    end
      
(* Common pattern for cost constraint :
     cost + post_potential <= a_cost + pre_potential
 *)
datatype {Time} {Time} {Nat} {Nat} 'a some_output_and_cost_constraint =
         SomeOutputAndCostConstaint
           {capa size capa' size' : Nat} {cost amortized_cost : Time}
           {cost + ite (2 * size' >= capa') ($(2 * size')) ($capa' / 2) + ite (2 * size >= capa) $capa $size <= ite (2 * size >= capa) ($(2 * size)) ($capa / 2) + ite (2 * size' >= capa') $capa' $size' + amortized_cost}
         of {size'} {capa'} 'a table --> {cost} {amortized_cost} {size} {capa} 'a some_output_and_cost_constraint

(* An amortized computation is a closure (or "computation") whose cost is constrainted by the input and output capas in some manner.
   Note that the actual [cost] is existentially introduced and not visible from the type.
 *)
datatype {Time} {Nat} {Nat} 'a amortized_comp =
         AmortizedComp {capa size : Nat} {cost amortized_cost : Time} of
         (unit -- cost --> {cost} {amortized_cost} {size} {capa} 'a some_output_and_cost_constraint) -->                                                                                                          {amortized_cost} {size} {capa} 'a amortized_comp

fun insert ['a] {capa size : Nat} (x : 'a) (table : {size} {capa} 'a table) return {23.0} {size} {capa} 'a amortized_comp =
    AmortizedComp
      (fn () =>
          SomeOutputAndCostConstaint (insert' x table)
      )

fun delete ['a] {capa size : Nat} (x : 'a) (table : {size} {capa} 'a table) (* return {23.0} {size} {capa} 'a amortized_comp *) =
    let
      val Delete' delete' = delete' x table
    in
      AmortizedComp
        (fn () return {} {23.0} {size} {capa} 'a some_output_and_cost_constraint =>
            let
              val GoodCost table = delete' ()
            in
              SomeOutputAndCostConstaint table
            end
        )
    end

fun insert_or_delete ['a] {capa size : Nat} (is_insert : bool, x : 'a) (table : {size} {capa} 'a table) return using 20.0 =
    case is_insert of
        true => insert x table
      | false => delete x table

datatype 'a some_table =
         SomeTable {capa size : Nat} of {size} {capa} 'a table --> 'a some_table

fun insert_delete_seq ['a] {n capa size : Nat} (xs : {n} (bool * 'a) list) (table : {size} {capa} 'a table) return 'a some_table using 48.0 * $n + ite (2 * size >= capa) ($(2 * size - capa)) ($capa / 2 - $size) =
    case xs of
        Nil => SomeTable table
      | Cons (x, xs) =>
        let
          val AmortizedComp f = insert_or_delete x table
          val SomeOutputAndCostConstaint table = f ()
          val table = insert_delete_seq xs table
        in
          table
        end
          
absidx T_insert_delete_seq_from_good_start : BigO 1 (fn n => $n) with
fun insert_delete_seq_from_good_start ['a] {n capa size : Nat} {ite (2 * size >= capa) ($(2 * size - capa)) ($capa / 2 - $size) <= $n} (xs : {n} (bool * 'a) list) (table : {size} {capa} 'a table) return 'a some_table using T_insert_delete_seq_from_good_start n =
    insert_delete_seq xs table using 2.0 + 49.0 * $n
end
          
absidx T_insert_delete_seq_from_empty : BigO 1 (fn n => $n) with
fun insert_delete_seq_from_empty ['a] {n : Nat} (xs : {n} (bool * 'a) list) (table : {0} {0} 'a table) return 'a some_table using T_insert_delete_seq_from_empty n =
    insert_delete_seq xs table using 2.0 + 48.0 * $n
end

end

