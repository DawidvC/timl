datatype {Nat} 'a list =
         nil of unit -> {0} 'a list
         | cons of {n : Nat} 'a * {n} 'a list -> {n + 1} 'a list

(* val g = *)
(*  fn {n : Nat} (xs : {n} int list) return |> 0.0 => xs *)

(* val g = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O _ $n => xs *)

abstype idx gg : {gg : Fun 1 | gg O (fn n => $n)} = _ with
val g =
 fn {n : Nat} (xs : {n} int list) return |> gg n => xs
end

abstype idx hh : {hh : Fun 1 | hh O (fn n => 1.0)} = _ with
val h =
 fn {n : Nat} (xs : {n} int list) return |> hh n => xs
end

abstype idx ff : {ff : Fun 1 | ff O _} with
val f =
 fn {n : Nat} (xs : {n} int list) return |> ff n =>
    let
        val xs = g {_} xs
        val xs = h {_} xs
    in
        xs
    end
end

(*
val ['a] ['b] map = 
 fn {m : Time} (f : 'a -- m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} 'a list) return {n} 'b list |> (m + 2.0) * $n =
            case ls return {n} 'b list of
                nil => nil
              | cons {n'} (x, xs) => cons {_} (f x, map {_} xs) |> (m + 2.0) * $n
    in
        map
    end
*)

abstype idx g : {g : Fun 1 | g O (fn n => $n)} = _ with
val ['a] ['b] map = 
 fn {m : Time} (f : 'a -- m --> 'b) =>
    let
        fun map {n : Nat} (ls : {n} 'a list) return {n} 'b list |> m * g n =
            case ls return {n} 'b list |> m * g n of
                nil => nil
              | cons {n'} (x, xs) => cons {_} (f x, map {_} xs)
    in
        map
    end
end

(* val g =  *)
(*     let *)
(*         type idx c1 : Profile = _ *)
(*     in *)
(*         fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)
(*     end *)

(* local *)
(*     type idx c1 : Profile = _ *)
(* in *)
(* type idx c1 : Profile = c1 *)
(* val g = fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)
(* end *)

(* local *)
(*     type idx c1 : Profile = _ *)
(* in *)
(* val g = fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)
(* end *)

(* type idx c1 : Profile = _ *)
(* val g = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)

(* type idx c2 : Profile = _ *)
(* val h = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O c2 $1 => xs *)

(* type idx c3 : Profile = _ *)
(* val f = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O c3 $n => *)
(*     let *)
(*         val xs = g {_} xs *)
(*         val xs = h {_} xs *)
(*     in *)
(*         xs *)
(*     end *)

        (*

exists {c : Time} {ub : Time}, forall {n : Nat}, {n} 'a list -- max ub (c * $n * log2 $n) --> {n} 'a list

exists {c : BigOConsts}, forall {n : Nat}, {n} 'a list -- O c ($n * log2 $n) --> {n} 'a list

exists {g : O (n => $n * log2 $n)}, forall {n : Nat}, {n} 'a list -- g n --> {n} 'a list

==========================
O (ub1,c1) (n * log n) + O (ub2,c2) n <= O ((ub1+ub2)/c2+1.73,c1+1.0) (n * log n)

==========================
exists c, O c1 (n * log n) + O c2 n <= O c (n * log n)

idx c1

idx c2

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- O c1 m * O c2 ($n * log2 $n) --> {n} 'a list

<->

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- O m * O ($n * log2 $n) --> {n} 'a list

==========================
exists c, O c1 n + O c2 n + O c3 1 <= O c n

        *)

