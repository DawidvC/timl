datatype {Nat} 'a list =
         nil of unit -> {0} 'a list
         | cons of {n : Nat} 'a * {n} 'a list -> {n + 1} 'a list

(* val g = *)
(*  fn {n : Nat} (xs : {n} int list) return |> 0.0 => xs *)

(* val g = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O _ $n => xs *)

abstype idx c1 : Profile = _ with
val g =
 fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs
end

abstype idx c2 : Profile = _ with
val h =
 fn {n : Nat} (xs : {n} int list) return |> O c2 $1 => xs
end

abstype idx c3 : Profile = _ with
val f =
 fn {n : Nat} (xs : {n} int list) return |> O c3 $n =>
    let
        val xs = g {_} xs
        val xs = h {_} xs
    in
        xs
    end
end

(* val g =  *)
(*     let *)
(*         type idx c1 : Profile = _ *)
(*     in *)
(*         fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)
(*     end *)

(* local *)
(*     type idx c1 : Profile = _ *)
(* in *)
(* type idx c1 : Profile = c1 *)
(* val g = fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)
(* end *)

(* local *)
(*     type idx c1 : Profile = _ *)
(* in *)
(* val g = fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)
(* end *)

(* type idx c1 : Profile = _ *)
(* val g = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O c1 $n => xs *)

(* type idx c2 : Profile = _ *)
(* val h = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O c2 $1 => xs *)

(* type idx c3 : Profile = _ *)
(* val f = *)
(*  fn {n : Nat} (xs : {n} int list) return |> O c3 $n => *)
(*     let *)
(*         val xs = g {_} xs *)
(*         val xs = h {_} xs *)
(*     in *)
(*         xs *)
(*     end *)

        (*

exists {c : Time} {ub : Time}, forall {n : Nat}, {n} 'a list -- max ub (c * $n * log2 $n) --> {n} 'a list

exists {c : BigOConsts}, forall {n : Nat}, {n} 'a list -- O c ($n * log2 $n) --> {n} 'a list

exists {g : O (n => $n * log2 $n)}, forall {n : Nat}, {n} 'a list -- g n --> {n} 'a list

==========================
O (ub1,c1) (n * log n) + O (ub2,c2) n <= O ((ub1+ub2)/c2+1.73,c1+1.0) (n * log n)

==========================
exists c, O c1 (n * log n) + O c2 n <= O c (n * log n)

idx c1

idx c2

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- O c1 m * O c2 ($n * log2 $n) --> {n} 'a list

<->

merge_sort : forall 'a {m : Time}, ('a * 'a -- m --> bool) -- 0.0 --> forall {n : Nat}, {n} 'a list -- O m * O ($n * log2 $n) --> {n} 'a list

==========================
exists c, O c1 n + O c2 n + O c3 1 <= O c n

        *)

