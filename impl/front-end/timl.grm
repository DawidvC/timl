open Ast

%%

%name TiML

%term ID of string
    | LPAREN
    | RPAREN
    | DRARROW
    | FN
    | FIX
    | LSQ
    | RSQ
    | LCUR
    | RCUR
    | CASE
    | OF
    | COLON
    | RTRI
    | LET
    | IN
    | END
    | COMMA
    | RETURN
    | ARROW
    | DDASH
    | MULT
    | PLUS
    | MU
    | INT of int
    | BAR
    | AND
    | OR
    | IFF
    | EQ
    | LE
    | VAL
    | EOF
    | FORALL
    | EXISTS
      (* | APP (* dummy terminal for precedence *) *)
    | MAX
    | MIN
    | BOGUS of string

%nonterm start of exp
       | exp of exp
       | aexp of exp
       | ty of ty
       | aty of ty
       | idx of idx
       | sort of sort
       | bsort of bsort
       | prop of prop
       | exp_comma_star of exp list
       | comma_exp_star of exp list
       | abs of abs
       | binding_plus of binding list
       | binding_star of binding list
       | binding of binding
       | return_opt of (ty * idx) option
       | return of ty * idx
       | rule_bar_star of (ptrn * exp) list
       | bar_rule_star of (ptrn * exp) list
       | rule of ptrn * exp
       | ptrn of ptrn
       | id_cur_space of string list
       | id_plus of string list
       | id_star of string list
       | def_star of def list
       | def of def
       | quan of quan


%keyword FN FIX CASE OF LET IN END RETURN VAL

%pos pos

		(* %nonassoc LET *)
		(* %nonassoc RTRI *)
%nonassoc IFF
%right ARROW
%right OR
%right AND
%nonassoc EQ LE
%left PLUS
%left MULT MAX MIN
		(* %left APP *)

%eop EOF
%noshift EOF
%nodefault
%verbose

%arg (reporter) : reporter

%%

start : exp (exp)

exp : aexp (aexp)
    | exp aexp (App (exp, aexp, (expleft, aexpright)))
    | exp LSQ ty RSQ (AppT (exp, ty, (expleft, tyright)))
    | exp LCUR idx RCUR (AppI (exp, idx, (expleft, idxright)))
    | exp COLON ty (Ascription (exp, ty, (expleft, tyright)))
    | exp RTRI idx (AscriptionTime (exp, idx, (expleft, idxright)))

aexp : ID (Var (ID, (IDleft, IDright)))
     | LPAREN exp_comma_star RPAREN (Tuple (exp_comma_star, (LPARENleft, RPARENright)))
     | abs binding_plus DRARROW exp (Abs (abs, binding_plus, exp, (absleft, expright)))
     | CASE exp return_opt OF rule_bar_star (Case (exp, return_opt, rule_bar_star, (CASEleft, rule_bar_starright)))
     | LPAREN exp RPAREN (exp)
     | LET def_star IN exp END (Let (def_star, exp, (LETleft, ENDright)))

ty : aty (aty)
   | ty aty (AppTT (ty, aty, (tyleft, atyright)))
   | ty LCUR idx RCUR (AppTI (ty, idx, (tyleft, RCURright)))
   | ty DDASH idx ARROW ty (Arrow (ty1, idx, ty2, (ty1left, ty2right)))
   | ty MULT ty (Prod (ty1, ty2, (ty1left, ty2right)))
   | ty PLUS ty (Sum (ty1, ty2, (ty1left, ty2right)))

aty : ID (VarT (ID, (IDleft, IDright)))
    | quan binding_plus COMMA ty (Quan (quan, binding_plus, ty, (quanleft, tyright)))
    | MU ID binding_star COMMA ty (Recur (ID, binding_star, ty, (MUleft, tyright)))
    | LPAREN ty RPAREN (ty)

idx : ID (VarI (ID, (IDleft, IDright)))
    | INT (Tint (INT, (INTleft, INTright)))
    | idx PLUS idx (Tadd (idx1, idx2, (idx1left, idx2right)))
    | idx MULT idx (Tmult (idx1, idx2, (idx1left, idx2right)))
    | idx MAX idx (Tmax (idx1, idx2, (idx1left, idx2right)))
    | idx MIN idx (Tmin (idx1, idx2, (idx1left, idx2right)))
    | LPAREN RPAREN (TTI (LPARENleft, RPARENright))
    | LPAREN idx RPAREN (idx)

sort : bsort (Basic (bsort, (bsortleft, bsortright)))
     | LCUR ID COLON bsort BAR prop RCUR (Subset (bsort, ID, prop, (LCURleft, RCURright)))

bsort : ID (Bsort (ID, (IDleft, IDright)))

prop : ID (Pconst (ID, (IDleft, IDright)))
     | prop AND prop (And (prop1, prop2, (prop1left, prop2right)))
     | prop OR prop (Or (prop1, prop2, (prop1left, prop2right)))
     | prop ARROW prop (Imply (prop1, prop2, (prop1left, prop2right)))
     | prop IFF prop (Iff (prop1, prop2, (prop1left, prop2right)))
     | idx EQ idx (Eq (idx1, idx2, (idx1left, idx2right)))
     | idx LE idx (TimeLe (idx1, idx2, (idx1left, idx2right)))

exp_comma_star : exp comma_exp_star (exp :: comma_exp_star)
	       | ([])

comma_exp_star : COMMA exp comma_exp_star (exp :: comma_exp_star)
	       | ([])

abs : FN (Fn)
    | FIX (Fix)

binding_plus : binding binding_star (binding :: binding_star)
binding_star : binding binding_star (binding :: binding_star)
	     | ([])

binding : ID COLON ty (Typing (ID, ty, (IDleft, tyright)))
	| LSQ ID RSQ (Kinding (ID, (LSQleft, RSQright)))
	| LCUR ID COLON sort RCUR (Sorting (ID, sort, (LCURleft, RCURright)))
	| LPAREN binding RPAREN (binding)

return_opt : return (SOME return)
	   | (NONE)

return : RETURN ty RTRI idx ((ty, idx))

rule_bar_star : rule bar_rule_star (rule :: bar_rule_star)
	      | ([])

bar_rule_star : BAR rule bar_rule_star (rule :: bar_rule_star)
	      | ([])

rule : ptrn DRARROW exp ((ptrn, exp))

ptrn : ID id_cur_space ID (Constr (ID1, id_cur_space, ID2, (ID1left, ID2right)))

id_cur_space : LCUR id_plus RCUR (id_plus)
	    | ([])

id_plus : ID id_star (ID :: id_star)
id_star : ID id_star (ID :: id_star)
	| ([])

def_star : def def_star (def :: def_star)
	 | ([])

def : VAL ID EQ exp (Val (ID, exp, (VALleft, expright)))

quan : FORALL (Forall)
     | EXISTS (Exists)
